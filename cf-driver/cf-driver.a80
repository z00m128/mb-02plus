;-------------------------------------;
;    CF Driver for MB-03+ Ultimate    ;
;-------------------------------------;
; (c) 2020 z00m^SinDiKAT
; formatted for SjASMPlus

; Version: 1.0

		device	zxspectrum48

; definitions

screen:		equ	#4000
attrs:		equ	#5800
ula:		equ	#fe

;ATA ports MB03
;p_data:		equ	195			;#c3
;p_error:	equ	167			;#a7
;p_sec_count:	equ	203			;#cb
;p_sec_number:	equ	175			;#af
;p_cyl_low:	equ	211			;#d3
;p_cyl_high:	equ	183			;#b7
;p_device_head:	equ	219			;#db
;p_command:	equ	191			;#bf
;p_status:	equ	191			;#bf

;ATA ports PVL
p_data:		equ	163			;#a3
p_error:	equ	167			;#a7
p_sec_count:	equ	171			;#ab
p_sec_number:	equ	175			;#af
p_cyl_low:	equ	179			;#b3
p_cyl_high:	equ	183			;#b7
p_device_head:	equ	187			;#bb
p_command:	equ	191			;#bf
p_status:	equ	191			;#bf

;ATA commands
c_identify:	equ 	#ec
c_readsector:	equ	#20

;ATA variables
ata_timeout:	equ	0			; timeout for ATA operations, 0 = max
s_ata_ready:	equ	%01000000		; status ready
s_ata_drq:	equ	%00001000		; status data request

;other
print_num:	equ	#1a1b			; ROM routine - prints number in BC
print_char:	equ	#0010			; ROM routine - prints char in A
chan_open:	equ	#1601			; ROM routine - open channel in A
key_scan:	equ	#028e			; ROM routine - keyboard scanning
scr_ct:		equ	#5c8c			; system variable - count scrolls

;MAIN code
		org	#6000

start:		ei

		ld	a,#02			; open print channel
		call	chan_open


title_screen:	xor	a

		ld	(scr_ct),a		; "disable" scroll? question
		xor	a			; set master device

		out	(ula),a			; black border

		call	clear_screen

		call	print_s_a
		db	#16,0,0			; AT 0,0
		db	#11,0			; PAPER 0
		db	#10,4			; INK 4
		db	#13,0			; BRIGHT 1
		db	"+------------------------------+"
		db	"|   "
		db	#10,6			; INK 6
		db	"MB-03+ Ultimate CF Driver"
		db	#10,4			; INK 4
		db	"  |"
		db	"+------------------------------+"
		db	"v1.0         "
		db	#7f
		db	"2020 z00m^SinDiKAT"
		db	#13,0			; BRIGHT 0
		db	#10,5			; INK 5
		db	#0d,#0d			; 2x ENTER
		dc	"CF Card: "

		or	a			; clear carry

		ld	hl,mas_id_buffer
		call	get_identify		; get identify data

		ld	hl,mas_mbr_buffr
		call	get_mbr			; get MBR

		ld	hl,mas_id_buffer
		call	device_name		; print name

		ld	ix,mas_id_buffer	
		call	device_params		; print parameters

		ld	ix,mas_mbr_buffr
		call	device_partit		; print partitions

		ld	ix,mas_mbr_buffr
		call	detect_47h		; find parition type 47h

		jp	basic

;--------------------------------------
; Print device error message
; output: c = error

device_error:	call	print_s_a
		db	#10,2			; INK 2
		db	#12,1			; FLASH 1
		db	"Device error or "
		db	"not present!"
		db	#12,0			; FLASH 0
		db	#10,7			; INK 7
		db	#0d,#0d+#80		; 2x ENTER
		jp	basic

;--------------------------------------
; Print device name
; input: HL = buffer of identify block

device_name:	ld	de,#36			; device name starts at 54th byte in buffer
		add	hl,de
		ld	b,#16			; we will read 22 chars only
		call	byteswap		; name is in little endian format
		call	print_s_na		; print name
		ld	a,#0d			; ENTER
		rst	#10
		ret		

;--------------------------------------
; Print device parameters
; input: IX = buffer of identify block

device_params:	call	print_s_a
		db	"C/H/S: "
		db	#10,7+#80		; INK 7

		ld	c,(ix+#02)		; buffer pointer to Cyl
		ld	b,(ix+#03)
		call	print_num
		ld	a,'/'
		rst	#10

		ld	c,(ix+#06)		; buffer pointer to Hea
		ld	b,(ix+#07)
		call	print_num
		ld	a,'/'
		rst	#10

		ld	c,(ix+#0c)		; buffer pointer to Sec
		ld	b,(ix+#0d)
		call	print_num
		ld	a,#20			; SPACE
		rst	#10

		call	print_s_a
		db	#10,5			; INK 5
		db	" LBA: "
		db	#10,7+#80		; INK 7
		ld	a,(ix+#63)		; LBA support ?
		bit	1,a
		ld	hl,msg_yes
		jr	nz,dp_lba_y
		ld	hl,msg_no
dp_lba_y:	call	print_sa_lp
		ld	a,#0d			; ENTER
		rst	#10

		call	print_s_a
		db	#10,5			; INK 5
		db	"Capacity: "
		db	#10,7+#80		; INK 7

		ld	c,(ix+#02)		; bc = cyl
		ld	b,(ix+#03)
		ld	h,(ix+#06)		; h = hea		
		ld	e,(ix+#0c)		; e = sec	
		call	size_count		; count size in MB from CHS
		ld	c,0			; only valid numbers will be printed
		ld	b,#0a			; max 10 characters
		call	DEC32X			; print size in MB
		call	print_s_a
		db	" MB"
		db	#0d+#80			; ENTER
		ret

msg_yes:	dc	"Yes"
msg_no:		dc	"No"

;--------------------------------------
; Print device partitions
; output: c = error, nc = MBR is valid

device_partit:	call	print_s_a
		db	#10,5			; INK 5
		db	"Partitions:"
		db	#10,7+#80		; INK 7

		push	ix
		pop	hl
		ld	de,#1fe			; set offset to signature
		add	hl,de
		ex	hl,de
		ld	a,(de)
		ld	l,a
		inc	de
		ld	a,(de)
		ld	h,a
		ld	bc,#aa55		; signature
		or	a
		sbc	hl,bc
		jr	z,signatr_valid		; go to part detect if it is valid
		ld	a,#02			; else red border
		out	(ula),a
		call	print_s_a		; and error message
		db	#12,1			; FLASH 1
		db	"Bad MBR or not valid!"
		db	#12,0			; FLASH 0
		db	#0d,#0d+#80		; 2x ENTER
		scf
		ret

signatr_valid:	call	print_s_a
		db	#10,5			; INK 5
		db	#0d+#80			; ENTER

		ld	de,#1be			; set offset to 1st partition entry
		add	ix,de
		ld	bc,1			; 1st partition entry
dev_part2:	push	bc
		ld	a,#10
		rst	#10
		ld	a,5
		rst	#10
		call	print_num
		call	print_s_a
		db	":"
		db	#10,7+#80		; INK 7		
		ld	a,(ix+4)
		cp	#00			; empty entry
		jr	z,part_none
		call	part_type		; detects a few types of partitions
		jr	next_entry

part_none:	call	print_s_a
		dc	"none "

next_entry:	pop	bc
		ld	de,#10
		add	ix,de			; next partition entry
		ld	a,#05
		inc	bc
		cp	c
		jr	nz,dev_part2		; quit if we scanned all 4 entries
		ld	a,#0d
		rst	#10			; ENTER
		ld	a,#0d
		rst	#10			; ENTER
		ret

part_type:	cp	#04			; FAT16, less than 32MB
		jp	z,part_fat16
		cp	#05			; extended CHS
		jp	z,part_extended
		cp	#06			; FAT16B (BigFAT)
		jp	z,part_fat16
		cp	#07			; HPFS/NTFS/exFAT
		jp	z,part_ntfs
		cp	#0b			; FAT32 CHS
		jp	z,part_fat32
		cp	#0c			; FAT32 LBA
		jp	z,part_fat32
		cp	#0e			; FAT16B LBA
		jp	z,part_fat16
		cp	#0f			; extended LBA
		jp	z,part_extended
		cp	#47			; MB02+
		jp	z,part_mb02
		cp	#48			; SFS
		jp	z,part_sfs
		cp	#82			; Linux swap
		jp	z,part_swap
		cp	#83			; Linux native
		jp	z,part_linux
		cp	#85			; Linux extended
		jp	z,part_extended	
		cp	#a5			; BSD slice
		jp	z,part_bsd
		cp	#a6			; OpenBSD slice
		jp	z,part_bsd
		cp	#a9			; NetBSD slice
		jp	z,part_bsd
		call	print_s_a
		dc	"unknown "
		ret

part_fat16:	call	print_s_a
		dc	"FAT16 "
		ret	

part_fat32:	call	print_s_a
		dc	"FAT32 "
		ret

part_ntfs:	call	print_s_a
		dc	"NTFS "
		ret

part_mb02:	call	print_s_a
		db	#13,1		; BRIGHT 1
		db	"MB02 "
		db	#13,0+#80	; BRIGHT 0
		ret

part_sfs:	call	print_s_a
		dc	"SFS "
		ret

part_linux:	call	print_s_a
		dc	"Linux "
		ret

part_swap:	call	print_s_a
		dc	"swap "
		ret

part_bsd	call	print_s_a
		dc	"BSD "
		ret

part_extended:	call	print_s_a
		dc	"extended "
		ret

;--------------------------------------
; looks for partition type 47h
; input: IX = buffer with MBR

detect_47h:	ld	de,#1be			; set offset to 1st partition entry
		add	ix,de
		ld	bc,1			; 1st partition entry
detect_47h_1:	push	bc
		ld	a,(ix+#04)
		cp	#00			; empty entry
		jr	z,detect_47h_2
		cp	#47			; type MB02
		jr	z,found_47h

detect_47h_2:	pop	bc
		ld	de,#10
		add	ix,de			; next partition entry
		ld	a,#05
		inc	bc
		cp	c
		jr	nz,detect_47h_1
		call	print_s_a
		db	#12,1			; FLASH 1	
		db	"There was no "
		db	"partiton type  47h "
		db	"on the device."
		db	#12,0			; FLASH 0
		db	#0d,#0d+#80		; ENTER
		ret

;--------------------------------------
; Partition type 47h handling

found_47h:	pop	bc
		call	print_s_a
		db	#10,5			; INK 5
		db	"Type 47h location: "
		db	#10,7			; INK 7
		db	#13,1+#80		; BRIGHT 1
		call	print_num		; prints partition number
		call	print_s_a
		db	#13,0			; BRIGHT 0
		db	#10,5			; INK 5
		db	#0d			; ENTER
		db	"Size: "
		db	#10,7			; INK 7
		db	#13,1+#80		; BRIGHT 1

		push	ix			; save buffer with MBR

		ld	l,(ix+#0c)		; SEC 0
		ld	h,(ix+#0d)		; SEC 1
		ld	e,(ix+#0e)		; SEC 2
		ld	d,(ix+#0f)		; SEC 3

		push	hl			; save DEHL
		push	de

		ld	c,0			; print only valid numbers
		ld	b,#0a			; max 10 characters
		call	DEC32X
		call	print_s_a
		db	#13,0			; BRIGHT 0
		db	#10,5			; INK 5
		db	" sectors"
		db	#0d+#80			; ENTER
		call	print_s_a
		db	"Drives count: "
		db	#10,7			; INK 7
		db	#13,1+#80		; BRIGHT 1

		pop	hl			; restore HLIX
		pop	ix

		ld	bc,#1000
		call	div32_16		; counts how many drives would be from available space, result in HLIX
						
		ld	b,xh			; the result will be 16 bit only, so we can truncate HL here
		ld	c,xl
		push	bc

		or	a			; clear carry flag
		
		ld	hl,#fc
		sbc	hl,bc			; max 252 drives allowed
		jr	nc,found_47h_1

		call	print_num
		call	print_s_a
		db	#13,0			; BRIGHT 0
		db	#10,2			; INK 2
		db	#0d
		db	"Partition is too big!"
		db	#0d
		db	"Only 252 drives "
		db	"will be used!"
		db	#0d+#80
		pop	bc
		ld	b,0
		ld	a,#fc			; limit to 252 drives if partition is bigger
		ld	c,a
		push	bc
		call	print_s_a
		db	#10,5			; INK 5
		db	"Occupied drives: "
		db	#10,7			; INK 7
		db	#13,1			; BRIGHT 1
		dc	"@3 - @"
		jr	found_47h_2

found_47h_1:	call 	print_num		; prints number of virtual drives
		call	print_s_a
		db	#13,0			; BRIGHT 0
		db	#10,5			; INK 5
		db	#0d			; ENTER
		db	"Occupied drives: "
		db	#13,1			; BRIGHT 1
		db	$10,7			; INK 7
		dc	"@3 - @"
found_47h_2:	pop	bc
		ld	a,c
		ld	hl,num_of_drives
		ld	(hl),a			; save number of drives for later usage
		add	a,2			; virtual drives starts from @3
		ld	c,a
		call	print_num
		call	print_s_a
		db	#13,0			; BRIGHT 0
		db	#10,5			; INK 5
		db	#0d+#80			; ENTER
		pop	ix
		ret

;--------------------------------------
; Reads Identify block
; input:  HL = buffer for identify block

get_identify:	ld	a,(master_slave)
		or	%10100000
		out	(p_device_head),a	; select master/slave
	
		ld	a,c_identify		; send identify command
		out	(p_command),a
		call	wait_ata_drq		; check for device ready and drq
		jp	c,device_error		; quit to error handling if not

		ld	bc,p_data		; load identify data
		inir
		inir
		call	wait_ata_ready		; check for device ready
		jp	c,device_error		; quit to error handling if not

		ret

;-------------------------------------
; Reads MBR
; input: HL = buffer for MBR

get_mbr:	ld	a,(master_slave)
		or	%10100000
		out	(p_device_head),a	; select master/slave

		ld	de,#0000		; cyl = 0
		ld	bc,#0001		; hea = 0, sec = 1
		ld	a,#01			; num of secs = 1
		out	(p_sec_count),a		; set sector count
		ld	a,c
		out	(p_sec_number),a	; set sector number
		ld	a,e
		out	(p_cyl_low),a		; set cyl low value
		ld	a,d
		out	(p_cyl_high),a		; set cyl high value
		ld	a,c_readsector		; read sector command
		out	(p_command),a
		call	wait_ata_drq		; wait if device is ready and drq
		jp	c,device_error		; quit to error handling if not

		ld	bc,p_data		; load sector data
		inir
		inir
		call	wait_ata_ready		; wait if device is ready
		jp	c,device_error		; quit to error handling if not

		ret

;--------------------------------------
; Wait for device status:
; busy = 0 and ready = 1
; with timeout
; output: c  = timeout
;         nc = drive ready

wait_ata_ready:	ld	de,ata_timeout
w_a_rd1:	in	a,(p_status)		; read device status
		and	%11000000		; busy (#80) + ready (#40)
		cp	s_ata_ready		; #40 = ready
		ret	z
		dec	de
		nop				; some delay
		ld	a,d
		or	e
		jr	nz,w_a_rd1
		scf				; timeout occured
		ret

;--------------------------------------
; Wait for device status:
; busy = 0 and data request = 1
; with timeout
; output: c  = timeout
;         nc = drive ready

wait_ata_drq:	ld	de,ata_timeout
w_a_drq1:	in	a,(p_status)		; read device status
		and	%10001000		; busy (#80) + (drq) #08
		cp	s_ata_drq		; #08 = data request
		ret	z
		dec	de
		nop				; some delay
		ld	a,d
		or	e
		jr	nz,w_a_drq1
		scf				; timeout occured
		ret

;--------------------------------------
; Counts medium size from CHS
; input: BC = cyl, H = hea, E = sec
; output DEHL = size in MB

size_count:	push	bc		; save cyl
		call	mul8_8		; HL = hea * sec
		ld	d,h
		ld	e,l		; DE = hea * sec
		ld	bc,#200		; 512 bytes per sec
		ld	hl,0
		call	mul16_16	; DEHL = hea * sec * 512
		ld	bc,#400
		push	hl		; move DEHL to HLIX
		pop	ix
		ex	de,hl		; so here will be HLIX = hea * sec * 512
		call	div32_16	; HLIX = HLIX / 1024, result can be 16 bits in max,
		ld	d,hx		; so we can truncate HL here
		ld	e,lx		; DE = (hea*sec*512)/1024
		pop	bc		; restore cyl
		ld	hl,0
		call	mul16_16	; DEHL = ((hea*sec*512)/1024)*cyl
		ld	bc,#400
		push	hl		; move DEHL to HLIX
		pop	ix
		ex	de,hl		; so here will be HLIX = ((hea*sec*512)/1024)*cyl
		call	div32_16	; HLIX = HLIX / 1024 = size in MB
		ex	de,hl		; move HLIX to DEHL
		push	ix
		pop	hl
		ret			; DEHL = size in MB

;--------------------------------------
; H * E
; input: H = multiplier, E = multiplicand
; output: HL = Product

mul8_8:		ld	d,0
		ld	l,d
		ld	b,8
m8_8_lp1:	add	hl,hl
		jr	nc,m8_8_jp1
		add	hl,de
m8_8_jp1:	djnz	m8_8_lp1
		ret

;--------------------------------------
; DE * BC
; input: DE = multiplier, BC = multiplicand
; output: DEHL = product

mul16_16:	ld	hl,0
		ld	a,16
m16_16_lp1:	add	hl,hl
		rl	e
		rl	d
		jr	nc,m16_16_jp1
		add	hl,bc
		jr	nc,m16_16_jp1
		inc	de
m16_16_jp1:	dec	a
		jr	nz,m16_16_lp1
		ret

;--------------------------------------
; HLIX / BC
; input: HLIX = numerator, BC = denominator
; Output: HLIX = result
;           DE = remainder

div32_16:	ld	de,0
		ld	a,32
div32_16loop:	add	ix,ix
		adc	hl,hl
		ex	de,hl
		adc	hl,hl
		or	a
		sbc	hl,bc
		inc	ix
		jr	nc,cansub
		add	hl,bc
		dec	ix
cansub:		ex	de,hl
		dec	a
		jr	nz,div32_16loop
		ret

;--------------------------------------
; Clears screen

clear_screen:	ld	hl,screen		; clear screen
		ld	de,screen+1
		ld	bc,#17ff
		xor	a
		ld	(hl),a
		ldir

		ld	hl,attrs
		ld	de,attrs+1
		ld	bc,#2ff
		ld	a,#07
		ld	(hl),a
		ldir
		ret

;--------------------------------------
; Return to BASIC

basic:		di                     
		ld	iy,#5c3a         
		ld	hl,#2758          
		exx                    
		im	1                 
		ei                     
		ret

;--------------------------------------
; Byteswap - coverts big endian to
; little endian and vice versa
; input: HL = address
;        B = how many bytes

byteswap:	push	af
		push	hl
		push	bc
		rrc	b
byteswap1:	ld	a,(hl)
		inc	hl
		ld	c,(hl)
		dec	hl
		ld	(hl),c
		inc	hl
		ld	(hl),a
		inc	hl
		djnz	byteswap1
		pop	bc
		pop	hl
		pop	af
		ret

;--------------------------------------
; Print routine, string end autodetect
; prints through #02 / #1601
; usage: ld   a,#02
;        call #1601
;        call print
;        dc   "text" 
;    (or byte "tex",'t'|128)
;    (or db   "tex",'t'+128)

print_s_a:	pop	hl
		call	print_sa_lp
		push	hl
		ret		

print_sa_lp:	ld	a,(hl)
		bit	7,a
		push	af
		and	%01111111
		push	hl
		rst	#10
		pop	hl
		inc	hl
		pop	af
		jr	z,print_sa_lp
		ret

;--------------------------------------
; Print routine
; prints through #02 / #1601
; input: HL = text adress
;        B = number of characters

print_s_na:	ld	a,(hl)
		push	hl
		push	bc
		rst	#10
		pop	bc
		pop	hl
		inc	hl
		djnz	print_s_na
		ret

;--------------------------------------
; Print 32-bit number
; by Busy Soft, taken from BSDOS 308
; input: DEHL = 32bit number
;           C = char for leading zeroes (0 = only valid numbers, #20 = justify to right)
;           B = max len (10)

DEC32X:		push	hl
		push	de
		push	bc
		xor	a
		ld	de,DATA
		ld	b,#0A
DCC1:		ld	(de),a
		inc	de
		djnz	DCC1
		pop	bc
		pop	de
		push	de
		push	bc
		ld	b,#20
DCC2:		add	hl,hl
		ex	de,hl
		adc	hl,hl
		ex	de,hl
		push	bc
		push	de
		ld	bc,#0A0A
		ld	de,DATA
DCC3:		ld	a,(de)
		adc	a,a
		cp	c
		jr	c,DCC4
		sub	c
DCC4:		ld	(de),a
		ccf
		inc	de
		djnz	DCC3
		pop	de
		pop	bc
		djnz	DCC2
		ld	d,b
		pop	bc
		push	bc
		ld	e,b
		ld	hl,DATA-1
		add	hl,de
		dec	b
		jr	z,DCC8
DCC5:		ld	a,(hl)
		or	a
		jr	nz,DCC6
		ld	a,c
		db	#11
DCC6:		ld	c,'0'
DCC7:		or	c
		dec	hl
		or	a
		call	nz,print_char		; ROM - print character in A
		djnz	DCC5
DCC8:		ld	a,(hl)
		or	'0'
		rst	#10
		pop	bc
		pop	de
		pop	hl
		ret

;--------------------------------------
; Buffers and variables

master_slave:	db	0
num_of_drives:	db	0

DATA:		ds	11

mas_id_buffer:	ds	#200			; buffer for master device identify block
mas_mbr_buffr:	ds	#200			; buffer for master MBR

		savebin "cf-driver.bin",start,$-start
