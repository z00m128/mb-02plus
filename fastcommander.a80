;FAST COMMANDER 0.1delta
;by EYE^K3l 1998 & +GAMA 2002

;format poloziek
;00: identifikator
;01-02: cislo
;03-30: text (28)
;31: 0

		device	zxspectrum48
		

		org	24200
;posunul som na 24200, lebo +Gama to dal na 23296, aby mal viac miesta
;lenze prepise systemky a pokym si nebudem isty, ze ich netreba,
;tak mam istotu, ze to nepada kvoli tomu

;definicie pre lahsiu orientaciu v zdrojaku

;sluzby ROM BIOSu
rom_wr_protect	equ	#3c98			;ROM banka, zakazany zapis
dos_wr_protect	equ	#3c9A			;DOS banka, zakazany zapis
rom_wr_enabled	equ	#3c9c			;ROM banka, povoleny zapis
dos_wr_enabled	equ	#3c9e			;DOS banka, povoleny zapis

;sluzby FDC BIOSu
fdc_rdsec	equ	#04			;precitanie sektora z diskety
fdc_wrsec	equ	#05			;zapis sektora na disketu
fdc_setoff	equ	#11			;mod vypinania motorov
fdc_aktive	equ	#0c			;aktivuje danu mechaniku
fdc_pasive	equ	#0d			;vypne aktivnu mechaniku, ci vypne motor zavisi od SETOFF
fdc_info	equ	#0e			;informacie o danej mechanike

;sluzby BSDOSu
dos_dec8x	equ	#05			;vypisuje osembitove cislo ako desiatkovu hodnotu
dos_dec16x	equ	#06			;vypisuje 16-bitove cislo ako desiatkovu hodnotu
dos_dec32x	equ	#07			;vypisuje 32-bitove cislo ako desiatkovu hodnotu
dos_dec32	equ	#08			;DEHL=DEHL-1
dos_add32	equ	#0a			;DEHL=DEHL+BC
dos_sddx	equ	#0c			;sposob vypisovania znakov pre sluzbu DISP
dos_howsec	equ	#0f			;vypocita kolko sektorov by na disku zaberal subor
dos_getcst	equ	#12			;zisti aktualnu cestu
dos_setdrv	equ	#13			;nastavenie aktualnej mechaniky
dos_setdir	equ	#14			;nastavenie aktualneho adresara na aktualnej mechanike
dos_getsub	equ	#16			;vrati v bufferi 32-bajtovu adresarovu polozku daneho suboru
dos_kolkox	equ	#18			;vrati dlzku adresara
dos_killx	equ	#1e			;zmazanie internych cache
dos_freex	equ	#1f			;vrati volne miesto na aktualnej diskete
dos_loa1x	equ	#22			;nahratie casti suboru
dos_utrasx	equ	#27			;utrasenie aktualneho adresara
dos_erasex	equ	#28			;zmazanie jedneho suboru
dos_erasix	equ	#29			;mazanie intervalu suborov
dos_messx	equ	#34			;ok/retry/abort okno
dos_sdmsx	equ	#35			;vypis chybovych hlaseni default/custom
dos_unerax	equ	#36			;obnovenie jedneho suboru
dos_unerix	equ	#37			;obnovenie intervalu suborov

;systemove premenne BSDOSu
XXX		equ	#03E0			;stlpec alebo nizsi bajt pozicie vypisu

;vlastny program
start:		di
		ld	sp,stack		;SP na vlastny stack
		call	dos_wr_enabled		;prestrankuje do DOSu
		call	status			;zisti konfiguraciu pocitaca

		xor	a
		out	(254),a			;cierny border

		ld	hl,interrupt		;interrupt na rutinu zobrazujucu hodiny
		ld	(#b1ff),hl		;!toto treba premysliet, mohlo by sa niecim poskodit!
		ld	a,#b1
		ld	i,a
		im	2
		ei

		call	OZNDEL1			;zrusi oznacenie v oboch paneloch
		call	OZNDEL2

		ld	a,2			;slpec vypisu=2 (lavy panel)
		ld	(draw_panel+1),a
		ld	(panely+1),sp		;odlozime si SP
		ld	(main+1),sp
panely1:	call	WORKB			;zobrazi panely
panely:		ld	sp,0			;obnovenie zasobnika

		ld	e,0			;ak nie je mechanika aktivna, motor sa bude vypinat
		ld	a,fdc_setoff		;sluzba SETOFF
		rst	#18			;FDC BIOS

		call	switch_panels		;prehodi sa na neaktivny panel
		call	swap_print		;vypis sa prepne na pravy panel
		call	refresh_pane1		;nacita a zobrazi subory v neaktivnom paneli
		call	switch_panels		;prehodi sa na aktivny panel
		call	swap_print		;vypis sa prepne na lavy panel
		call	refresh_pane1		;nacita a zobrazi subory v aktivnom paneli

main:		ld	sp,0			;obnovenie zasobnika
		call	CHANGE			;zisti ci nebol vymeneny disk
main1:		call	show_cursor		;nakresli kurzor

		ld	e,1			;vypis znakov bude prebiehat do pamate, nie na obrazovku
		ld	a,dos_sddx		;sluzba SDDX
		rst	#20			;BSDOS

		ld	hl,(FILE1)		;vezme cislo suboru
		ld	c,'0'			;nevyznamne nuly sa zobrazia
		ld	iy,NUMBER		;do iy ide adresa bufferu
		call	dec2char16_j+2		;ulozi cislo do pamate ako text
		ld	a,(draw_panel+1)	;v draw_panel+1 by malo byt 2, cize lavy panel
		add	a,20			;stlpec 2+22
		ld	l,a			;l=cislo stlpca
		ld	h,19			;h=cislo riadku
		ld	de,NUMBER		;de=adresa textu
		call	print64			;vytlacime cislo suboru

;Hlavny program pre obsluhu klavesnice
main0:		call	inkey			;zavola sa INKEY$ z ROM
		cp	11			;^ - kurzor hore
		jp	z,cursor_up
		cp	10			;v - kurzor dole
		jp	z,cursor_down
		cp	'0'			;0 - hlavne menu
		jp	z,UPPER
		cp	8			;< - lavy panel
		jp	z,panel_one
		cp	9			;> - pravy panel
		jp	z,panel_two
		cp	'1'			;1 - zmena mechaniky v aktivnom paneli - vlavo
		jp	z,chnge_drv_left
		cp	'2'			;2 - zmena mechaniky v aktivnom paneli - vpravo
		jp	z,chnge_drv_rght
		cp	'3'			;3 - viewer suboru, po sektoroch
		jp	z,VIEW
		cp	'5'			;5 - kopirovanie, sekvencne po sektoroch
		jp	z,COPY
		cp	'x'			;x - ukoncenie programu
		jp	z,EXIT
		cp	'd'			;d - zmena adresara
		jp	z,change_dir
		cp	'p'			;p - zotrasenie adresara
		jp	z,PRESS
		cp	'+'			;+ - oznacenie suborov
		jp	z,OZNALL
		cp	'*'			;* - zmena oznacenia suborov
		jp	z,UZNALL
		cp	'-'			;- - odznacenie suborov
		jp	z,ODZNALL
		cp	'i'			;i - informacie o adresari
		jp	z,II
		cp	7			;EDIT- oznacenie suborov podla masky
		jp	z,OZNMASK
		cp	13			;ENTER - oznacenie jedneho suboru
		jp	z,OZN
		cp	'8'			;8 - zmazanie oznacenych suborov
		jp	z,DELETE
		cp	'9'			;9 - premenovanie suboru
		jp	z,RENAME
		cp	'u'			;u - undelete suboru
		jp	z,UNDELETE
		ld	hl,main			;uschova adresy hlavneho programu kvoli refresh_pane
		push	hl			;lebo sa vracia priamo na MAIN, nie sem
		cp	'r'			;r - znovunacitanie disku
		jp	z,refresh_pane
		pop	hl			;obnova adresy hlavneho programu
		jr	main0

;Prepnutie vypisu panelov zo stlpca 2 (lavy panel), na stlpec 34 (pravy panel), and vice versa
swap_print:	ld	a,(draw_panel+1)	;nacitame nastavenie stlpca
		cp	2
		jr	z,swpp			;ak sme vlavo tak nic
		ld	a,2
		jr	swps
swpp:		ld	a,34			;inak sme vpravo
swps:		ld	(draw_panel+1),a
		ret

;Zobrazenie kurzora, je len atributovy
show_cursor:	ld	hl,(POZICE1)		;nacitame poziciu kurzora
		call	pixel_address		;zistime si pixelovu adresu
		call	attr_address		;vypocitame adresu atributu pod pixelovou adresou
		ld	b,14
sc_lp:		res	3,(hl)			;zobrazime kurzor
		inc	l
		djnz	sc_lp
		ret

;Zmazanie kurzora
hide_cursor:	ld	hl,(POZICE1)		;to iste ako v show_cursor,
hide_cursor1:	call	pixel_address
		call	attr_address
		ld	b,14
hc_lp:		set	3,(hl)			;len kurzor sa maze
		inc	l
		djnz	hc_lp
		ret

;zmena cisla mechaniky v aktivnom paneli, vlavo
chnge_drv_left:	call	hide_cursor		;skryje kurzor
		ld	a,(draw_panel+1)	;zisti sa ci je aktivovany
		cp	2			;lavy panel
		jp	z,change_drive		;ak ano, rovno pokracuje na zmenu mechaniky
		ld	a,2
		ld	(draw_panel+1),a	;ak nie je aktivovany
		call	switch_panels		;tak ho aktivuje
		ld	hl,PANEL1		;prepne ukazatele na buffre
		ld	(OORT1),hl
		ld	hl,PANEL1+512
		ld	(OORT2),hl
		jp	change_drive		;pokracujeme zmenou mechaniky

;zmena cisla mechaniky v aktivnom paneli, vpravo
chnge_drv_rght:	call	hide_cursor		;skryje kurzor
		ld	a,(draw_panel+1)	;zisti sa ci je aktivovany
		cp	34			;pravy panel
		jr	z,change_drive		;ak ano, rovno pokracuje na zmenu mechaniky
		ld	a,34
		ld	(draw_panel+1),a	;ak nie je aktivovany
		call	switch_panels		;tak ho aktivuje
		ld	hl,PANEL1		;opat prehodenie ukazatelov na buffre
		ld	(OORT1),hl
		ld	hl,PANEL1+512
		ld	(OORT2),hl
change_drive:	ld	a,(draw_panel+1)	;zmena mechaniky uz je spolocna pre oba smery
		srl	a			
		ld	b,0
		ld	c,a
		ld	hl,10*256-1		;vypocita sa pozicia pre ramcek okna dialogu
		add	hl,bc			;teda ci zobrazujeme ramcek vlavo, alebo vpravo
		ld	de,3*256+15
		call	IN			;schova obsah obrazovky pod oknom dialogu
		exx				;odlozi si registre kde mame poziciu ramceka
		ld	a,(draw_panel+1)
		ld	b,0
		ld	c,a
		ld	hl,11*256+0		;vypocita sa pozicia pre zobrazenie otazky
		add	hl,bc
		ld	de,txt_drive_num	;zobrazi sa otazka
		call	print64
		exx				;obnovi sa pozicia ramceka
		ld	a,120			;vykresli sa ramcek
		call	MENU2
		ld	a,(draw_panel+1)
		ld	b,0
		ld	c,a
		ld	hl,10*256+8		;vypocita sa poloha pre titulok dialogu
		add	hl,bc
		ld	de,txt_ch_drive		;vypise sa titulok
		call	print64

change_drv_in:	call	wait_5_ints		;pocka sa 5 preruseni
		ld	a,(draw_panel+1)
		ld	b,0
		ld	c,a
		ld	hl,11*256+23		;vypocita sa pozicia pre input
		add	hl,bc
		ld	de,#303a		;nastavenie intervalu pre input, akceptuju sa len cisla
		ld	a,(OPT)			;zisti sa ci je povoleny hdd (0-255 mechanik)
		bit	2,a
		jp	z,hdd_no		;ak nie, pokracovanie na osetrenie mechanik 1,2,3,4 a 9

;vstup znakov v pripade povoleneho hdd
hdd_yes:	ld	iyl,4			;sirka vstupu su 3 znaky a kurzor
		call	INTXT			;zavola sa input
		jr	nc,change_drv_in	;ak uzivatel stlaci break, tak sa opakuje? (nemalo by sa len vyskocit?)
		ld	de,TEXT			;nastavi sa na zaciatok zadaneho textu
		ld	hl,0
hdd_yes1:	ld	a,(de)			;precita sa znak
		sub	#30			;test na mechaniku 0?
		jr	c,hdd_yes2		;ak ano, tak tu by malo by skor jr c,change_drv_in
		cp	10
		jr	nc,hdd_yes2		;zisti sa ci to nie je koniec cisla
		inc	de			;posun na dalsi znak
		add	hl,hl			;v najblizsich krokoch sa vynasobi hl desiatimi
		ld	c,l
		ld	b,h
		add	hl,hl
		add	hl,hl
		add	hl,bc
		ld	c,a			;a pripocita sa uz precitane cislo
		ld	b,0
		add	hl,bc
		jr	hdd_yes1		;opakuje sa, kym nie je koniec cisla

hdd_yes2:	ld	e,l			;kontrola ci cislo nie je vacssie ako 255
		ld	a,h
		or	a
		jr	nz,change_drv_in	;navrat ak je, (chyba test na mechaniku 0, vid vyssie)
		jr	set_act_drv		;pokracovanie na nastavenie mechaniky

;vstup znakov v pripade nepovoleneho hdd
hdd_no:		ld	iyl,2			;sirka vstupu je 1 znak a kurzor
		call	INTXT			;zavola sa input
		jr	nc,change_drv_in	;ak uzivatel stlaci break, tak sa opakuje? (nemalo by sa len vyskocit?)
		ld	a,(TEXT)		;nacita sa prvy znak
		sub	#30			;test na mechaniku 0?
		jr	c,change_drv_in		;znova ak uzivatel zadal 0
		ld	hl,DRV9
		cp	9
		jr	z,hd_no_drv_err		;test ci je pritomna mechanika 9 (aktivny ramdisk)
		cp	5
		jr	nc,err_msg_cdrv		;ak su zadane mechaniky 5-8 nasleduje chybova hlaska
		or	a
		jr	z,err_msg_cdrv
		ld	hl,DRV4			;porovnanim s premennou obsahujucou pocet pripojenych mechanik
		ld	b,4			;skusa ci zadana mechanika (z 1-4) je pripojena
hd_no_lp:	cp	b
		jr	z,hd_no_drv_err
		dec	hl
		dec	hl
		djnz	hd_no_lp
hd_no_drv_err:	ld	e,a
		xor	a
		cp	(hl)
		jr	z,err_msg_cdrv		;ak nie je, nasleduje chybova hlaska

set_act_drv:	ld	a,e			;ak testy dopadli dobre, nastavi zadanu mechaniku na aktivnu
		ld	(active_drive_1),a

		ld	a,dos_setdrv		;sluzba SETDRV, v E mame cislo mechaniky
		rst	#20			;BSDOS

		call	OUT			;obnovi obsah obrazovky pod dialogom
		call	refresh_pane		;obnovenie obsahu panelu
		jp	main			;navrat do hlavneho programu

;vyhodi chybovu hlasku ak uzivatel zadal neplatnu mechaniku
err_msg_cdrv:	call	OUT			;obnovi obsah obrazovky pod dialogom

		ld	hl,txt_bad_string	;adresa chybovej hlasky
		ld	a,dos_messx		;sluzba MESSX
		rst	#20			;BSDOS

		call	wait_5_ints		;pocka 5 preruseni
		jp	c,change_drive		;ak bol stlaceny ENTER ide znova, inak navrat
		jp	main			;do hlavneho programu

txt_ch_drive:	db	"Change Drive"
		nop
txt_drive_num:	db	"Enter number of drive:      "
		nop

;Zmena adresara
change_dir:	ld	hl,10*256+7		;pozicia ramceka pre dialog
		ld	de,3*256+18
		call	IN			;uschova obsah obrazovky pod dialogom
		exx				;odlozi poziciu ramceka
		ld	hl,11*256+16		;pozicia dotazu na cislo adresara		
		ld	de,txt_dir_num
		call	print64			;vypis dotazu
		exx				;obnovi poziciu ramceka
		ld	a,120
		call	MENU2			;vykresli ramcek
		ld	hl,10*256+26		;pozicia titulku dialogu
		ld	de,txt_ch_dir
		call	print64			;vykresli titulok
		ld	hl,11*256+43		;pozicia pre input
		ld	de,#303a		;interval pre input (len cisla)
		ld	iyl,4			;sirka vstupu 3 znaky a kurzor
		call	INTXT			;zavola input
		jp	nc,cd_end_break		;ak bol stlaceny break, adresar sa nemeni
		call	A2N			;skonvertuje text na cislo (vrati ho v IX)
		jp	nc,err_msg_cdir		;ak uzivatel zadal blbost, skok na chybovu hlasku
		push	ix
		pop	hl
		ld	de,256			;kontrola na 256 (chyba - ma tu byt 255)
		call	cp_hl_de		;ak je cislo vacsie,
		jp	nc,err_msg_cdir		;skok na chybovu hlasku, inak zmena adresara

		ld	e,l			;do E dame cislo adresara
		ld	a,dos_setdir		;sluzba SETDIR
		rst	#20			;BSDOS

		call	OUT			;obnovi obsah obrazovky pod oknom dialogu
		call	refresh_pane		;znovunacita mechaniky
		jp	main			;navrat do hlavneho programu

cd_end_break:	call	OUT			;obnovi obsah obrazovky pod oknom dialogu
		jp	main			;navrat do hlavneho programu

err_msg_cdir:	call	OUT

		ld	hl,txt_bad_string	;adresa textu
		ld	a,dos_messx		;sluzba MESSX
		rst	#20			;BSDOS

		call	wait_5_ints		;pocka 5 preruseni
		jp	c,change_dir		;ak bol stlaceny ENTER ide znova, inak navrat
		jp	main			;do hlavneho programu

txt_ch_dir:	db	"Change Dir"
		nop
txt_dir_num:	db	"Enter number of"
		db	" directory:       "
		nop

;Vypis cisla adresara - pouzije sa len raz v znovunacitani obsahu panelu, takze by sa to asi dalo zaclenit
wr_dir_num:	push	hl			;v l mame cislo aktualneho adresara

		ld	e,1			;vypis znakov bude prebiehat do pamate, nie na obrazovku
		ld	a,dos_sddx		;sluzba SDDX
		rst	#20			;BSDOS

		ld	e,l			;v l stale mame cislo aktivneho adresara
		ld	c,'0'			;nevyznamne miesta nahradi nulami
		ld	iy,NUMBE+1		;miesto v pamati pre vypis
		call	dec2char8_j+2		;ulozi cislo do pamate ako text
		ld	a,(draw_panel+1)	;nasleduje nastavenie pozicie v paneli
		add	a,13
		ld	l,a
		ld	h,19
		ld	de,NUMBE
		call	print64			;a vykreslenie cisla do panelu
		pop	hl			;obnovime si cislo aktualneho adresara
		ret

;Znovunacitanie obsahu panelu
refresh_pane:	call	OZNDEL1			;zrusi oznacenie suborov

refresh_pane1:	ld	a,dos_killx		;sluzba KILLX zrusi buffre DOSu
		rst	#20			;BSDOS

		ld	a,(active_drive_1)	;nastavi aktivnu mechaniku

		ld	e,a			;v E mame cislo mechaniky
		ld	a,dos_setdrv		;sluzba SETDRV
		rst	#20			;BSDOS

		ld	a,(active_dir_1)	;nastavi aktualny adresar

		ld	e,a			;v E mame cislo adresara
		ld	a,dos_setdir		;sluzba SETDIR
		rst	#20			;BSDOS

rp_lp:		ld	a,(active_drive_1)	;vezme cislo aktivnej mechaniky
		ld	e,a
		call	activate_drive		;aktivuje mechaniku
		ld	hl,JIST1		;ukazatel na buffer
		ld	de,1			;d=stopa 0, l=strana 0, sektor 1
		call	read_sector		;precita boot sektor
		cp	2			;ak je chyba
		jr	nz,rp_lp		;opakuje citanie
		ld	hl,0			;nulovanie ukazatela na subor
		ld	(FILE1),hl
		ld	bc,0			;?cislo suboru sa nastavi na 0 = nulta adresarova polozka?
		ld	ix,PANEL1		;nastavi sa na buffer
		call	read_directory		;precita sa adresarova polozka
		ld	ix,PANEL1		;nastavi sa na buffer
		call	draw_panel		;vykresli obsah aktivneho panelu
		ld	hl,PANEL1		;nasleduje pozicia kurzora v buffri
		ld	(INPANEL1),hl
		ld	hl,2*256
		ld	a,(draw_panel+1)	;a vypocet jeho grafickej pozicie, kam sa bude kreslit
		ld	e,a
		ld	d,0
		add	hl,de
		ld	(POZICE1),hl		;ta sa ulozi do premennej

		ld	a,dos_getcst		;sluzba GETCST, zisti aktualnu cestu
		rst	#20			;BSDOS
						;vrati v d=aktualny adresar, v e=aktualny disk, v hl=load-kurzor

		ld	a,d			;zisteny aktualny adresar
		ld	(active_dir_1),a	;sa ulozi do premennej
		ld	l,d			
		call	wr_dir_num		;a vykresli do aktivneho panelu

		ld	a,dos_freex		;sluzba FREEX, vracia v dehl=volne miesto v bajtoch, bc=volne miesto v sektoroch 
		rst	#20			;BSDOS

		ret	nc			;navrat pri chybe
		
		push	bc			;odlozi si volne miesto v sektoroch

		ld	e,1			;vypis znakov bude prebiehat do pamate, nie na obrazovku
		ld	a,dos_sddx		;sluzba SDDX
		rst	#20			;BSDOS

		pop	bc			;vyberie volne miesto v sektoroch, ale je to zbytocne lebo sddx bc neposkodzuje
		
		ld	h,b			;prehodi si bc do hl, keby dal o riadkok vyssie pop hl	
		ld	l,c			;tak si tieto dva riadky usetri
		ld	c,'0'			;nevyznamne cisla nahradi nulami
		ld	iy,NUMBER		;miesto v pamati pre vypis
		call	dec2char16_j+2		;ulozi cislo do pamate ako text
		ld	h,21			;nastavi si graficku poziciu do panelu
		ld	a,(draw_panel+1)
		add	a,10
		ld	l,a
		ld	de,NUMBER
		call	print64			;a cislo tam vykresli
		ld	hl,JIST1+#26		;v JIST1 je boot sektor, takze si z neho 
		ld	de,NAME			;vezme meno disku
		ld	bc,10
		ldir				;presunie si ho do buffra
		ld	h,20			;a potom si nastavi graficku poziciu do panelu
		ld	a,(draw_panel+1)
		add	a,13
		ld	l,a
		ld	de,NAME
		call	print64			;a to meno disku vykresli
		ld	a,(active_drive_1)	;tuto sa ide vykreslit cislo mechaniky
		ld	e,a
		ld	c,'0'			;nevyznamne cisla nahradi nulami
		ld	iy,NUMBE+1		;miesto v pamati pre vypis
		call	dec2char8_j+2		;ulozi cislo do pamate ako text
		ld	a,(draw_panel+1)	;nastavi graficku poziciu
		add	a,7			
		ld	l,a
		ld	h,19
		ld	de,NUMBE
		call	print64			;a cislo vykresli
		ret

;Vypocita polohu kurzora v paneli a vykresli panel
;output: ix=polozka v bufferi, ktora oznacuje riadok, na ktorom je kurzor
cursor_pos_cnt:	ld	hl,(INPANEL1)		;poloha v paneli
		ld	a,(POZICE1+1)
		sub	2
		or	a
		jr	z,cp_not_count		;prepocet neprebehne ak sa poloha kurzora nezmenila
		ld	b,a
		ld	de,32
cp_count:	or	a			;vypocita sa nova poloha kurzora ak sa kurzor posunul
		sbc	hl,de
		djnz	cp_count
cp_not_count:	push	hl			;nastavi sa ukazatel v bufferi
		pop	ix
		call	draw_panel		;vytlaci sa panel
		jp	main			;a vrati do hlavneho programu

;Nastavi lavy panel ako aktualny
panel_one:	ld	a,(draw_panel+1)	;kontrola ci uz nie sme v lavom paneli
		cp	2
		jp	z,main			;ak ano navrat

		call	hide_cursor		;schovame kurzor
		ld	a,(active_drive_2)	;mechanika pre pasivny panel

		ld	e,a			;v E mame cislo mechaniky
		ld	a,dos_setdrv		;sluzba SETDRV
		rst	#20			;BSDOS

		ld	a,(active_dir_2)	;adresar pre pasivny panel

		ld	e,a			;v E mame cislo adresara
		ld	a,dos_setdir		;sluzba SETDIR
		rst	#20			;BSDOS

		jp	nc,main			;pri chybe navrat do hlavneho programu

		ld	a,2			;nastavi vypis na lavy panel (stlpec 2)
		ld	(draw_panel+1),a
		call	switch_panels		;prepne panely
		ld	hl,PANEL1		;diskoteka s bufframi
		ld	(OORT1),hl
		ld	hl,PANEL1+512
		ld	(OORT2),hl
		ld	a,(active_drive_1)	;porovna ci je nastavena mechanika v oboch paneloch rovnaka
		ld	hl,active_drive_2
		cp	(hl)
		jp	nz,main			;ak nie, tak navrat, lebo disketa uz je nacitana
		call	refresh_pane		;ak ano, tak precitaj disketu
		jp	main1			;a navrat

;Nastavi pravy panel ako aktualny.
;Je to skoro rovnaky podprogram ako panel_one.
;Asi sa to da zlucit do jedneho, len zavolat s rozdielnym cislom stlpca
panel_two:	ld	a,(draw_panel+1)	;kontrola ci uz nie sme v pravom paneli
		cp	34
		jp	z,main			;ak ano, tak navrat

		call	hide_cursor		;schovame kurzor
		ld	a,(active_drive_2)	;mechanika pre pasivny panel

		ld	e,a			;v E mame cislo mechaniky
		ld	a,dos_setdrv		;sluzba SETDRV
		rst	#20			;BSDOS

		ld	a,(active_dir_2)	;adresar pre pasivny panel

		ld	e,a			;v E mame cislo adresara
		ld	a,dos_setdir		;sluzba SETDIR
		rst	#20			;BSDOS

		jp	nc,main			;pri chybe navrat

		ld	a,34			;nastavi vypis na pravy panel (stlpec 34)
		ld	(draw_panel+1),a
		call	switch_panels		;prepne panely
		ld	hl,PANEL1		;diskoteka s bufframi
		ld	(OORT1),hl
		ld	hl,PANEL1+512
		ld	(OORT2),hl
		ld	hl,(POZICE1)		;?toto je asi navyse?
		ld	a,(active_drive_1)	;provna ci je mechanika v oboch paneloch rovnaka
		ld	hl,active_drive_2
		cp	(hl)
		jp	nz,main			;ak nie, tak navrat
		call	refresh_pane		;ak ano, tak znova nacita disketu
		jp	main1			;a navrat

;Prepne panely aktivny za pasivny
switch_panels:	call	OZNCHAN			;prepne informaciu o oznacenych suboroch z aktivneho do pasivneho panelu
		ld	hl,FILE2		;prepne buffery k panelom
		ld	de,FILE1
		ld	bc,2*1024+14		;a aj buffery k sektoru z panelu a boot sektoru
p_sw_lp:	ld	a,(hl)
		ld	xh,a			;inak tieto sarady s bufframi su hrozne
		ld	a,(de)			;je to tu uplne vsade
		ld	(hl),a			;preco negeneruje dva hotove buffre pre kazdy panel zvlast
		ld	a,xh			;a potom by stacilo prepinat pointery?
		ld	(de),a			;kvoli setreniu miestom to asi nebolo
		inc	hl
		inc	de
		dec	bc
		ld	a,b
		or	c
		jr	nz,p_sw_lp
		ret

;Posun kurzora dohora
cursor_up:	ld	ix,POZICE1		;kontrola ci uz nie je kurzor na vrchu
		ld	a,(ix+1)
		cp	2
		jr	z,cur_move_up:		;ak ano, odskok na odsun poloziek dohora
		ld	bc,(FILE1)		;inak znizi ukazatel na subor
		dec	bc
		ld	(FILE1),bc
		ld	l,(ix+0)		;prepocita polohu kurzora
		ld	h,a
		dec	a
		ld	(ix+1),a
		call	hide_cursor1		;schova kurzor
		ld	hl,(INPANEL1)		;znizi ukazatel v paneli o jednu polozku
		ld	de,32
		or	a
		sbc	hl,de
		ld	(INPANEL1),hl
		jp	do_main			;a navrat

;Znizi ukazatele na subor a prekresli panel
cur_move_up:	ld	bc,(FILE1)		;vezme ukazatel na subor
		dec	bc
		ld	h,b
		ld	l,c
		ld	de,65535
		call	cp_hl_de		;a zisti ci nie je na nultom subore
		jp	z,do_main		;ak ano navrat
		ld	(FILE1),bc		;ak nie vrati znizeny ukazatel nazad do premennej
		ld	hl,(INPANEL1)		;porovna polozku v paneli s polohou v ?buffri?
		ld	de,(OORT1)
		call	cp_hl_de
		jr	z,cmu_read_prev		;ak je na zaciatku buffra, odskok na nacitanie predchadzajucich poloziek adresara	
		or	a			;inak znizi aj ukazatel o jednu polozku
		ld	de,32
		sbc	hl,de
		push	hl
		pop	ix
		call	draw_panel		;a prekresli panel s posunutymi polozkami
		ld	hl,(INPANEL1)		;znova znizi polozku v paneli
		ld	de,32			;ale asi zbytocne, lebo pred chvilou to ratal
		or	a			;stacil dvakrat push hl a namiesto tohto pop hl	
		sbc	hl,de
		ld	(INPANEL1),hl		;ulozi znizenu polozku nazad do premennej
		jp	main1			;a navrat

;Nacita predchadzajuce polozky adresara
;tie operacie s bufframi su v celom programe pekelne, bolo by to treba zjednodusit
cmu_read_prev:	call	CHANGE			;test ci nam uzivatel pod zadkom nevymenil disketu
		ld	hl,(OORT1)		;?posun buffrov o 512 bytes?
		ld	de,(OORT2)		;?t.j. 16 poloziek?
		ld	bc,512
		ldir
		ld	hl,(FILE1)		;vezme povodny ukazatel na subory
		ld	de,15
		or	a
		sbc	hl,de			;odpocita 15 poloziek
		ld	b,h
		ld	c,l
		ld	ix,(OORT1)		;?nastavi sa na zaciatok buffrov?
		ld	a,16
		call	read_dir_1		;nacita 16 predoslych poloziek
		ld	ix,(OORT1)		;prepocita polohu v buffri
		ld	de,480
		add	ix,de
		call	draw_panel		;vykresli panel
		ld	hl,(OORT1)		;este ten isty prepocet
		ld	de,480			;pre panel
		add	hl,de
		ld	(INPANEL1),hl		;ulozi do premennej
		jp	main1			;a navrat

;Posun kurzora dole
cursor_down:	ld	ix,POZICE1		;kontrola ci uz nie je kurzor na spodku
		ld	a,(ix+1)
		cp	17
		jr	z,cur_move_down		;ak ano odskok na odsun poloziek dole
		ld	bc,(FILE1)		;inak zvysi ukazatel na subor
		inc	bc
		ld	(FILE1),bc
		ld	l,(ix+0)		;prepocita polohu kurzora
		ld	h,a
		inc	a
		ld	(ix+1),a
		call	hide_cursor1		;schova kurzor
		ld	hl,(INPANEL1)		;zvysi ukazatel v paneli o jednu polozku
		ld	de,32
		add	hl,de
		ld	(INPANEL1),hl
		jr	do_main			;a navrat

;Zvysi ukazatel na subor a prekresli panel
cur_move_down:	ld	bc,(FILE1)		;vezme ukazatel na subor
		inc	bc
		ld	d,b
		ld	e,c
		ld	hl,(LENDIR1)
		call	cp_hl_de		;zisti ci nie je na konci adresara
		jp	z,do_main		;ak je tak navrat
		ld	(FILE1),bc		;vrati zvyseny ukazatel do premennej
		ld	hl,(OORT1)		;?otestuje ci sme nevytiekli z buffra?
		ld	de,1024-32
		add	hl,de
		ex	de,hl
		ld	hl,(INPANEL1)		
		call	cp_hl_de
		jr	z,cmd_read_next		;ak ano tak nacitaj dalsie polozky
		ld	de,14*32		;posun ukazatela v paneli
		or	a
		sbc	hl,de
		push	hl
		pop	ix
		call	draw_panel		;vykreslenie panelu
		ld	hl,(INPANEL1)		;prepocet ukazatela v paneli
		ld	de,32
		add	hl,de
		ld	(INPANEL1),hl		;jeho ulozenie do premennej
		jp	main1			;a navrat

;Nacita nasledujuce polozky adresara
cmd_read_next:	call	CHANGE			;test ci uzivatel nevymenil diskety
		ld	hl,(OORT2)		;?posun buffrov o 16 poloziek?
		ld	de,(OORT1)
		ld	bc,512
		ldir
		ld	bc,(FILE1)		;vezme povodny ukazatel na subory
		ld	ix,(OORT2)
		ld	a,16
		call	read_dir_1		;precita 16 nasledujucich poloziek
		ld	ix,(OORT1)		;prepocita ukazatel v paneli
		ld	de,32
		add	ix,de
		call	draw_panel		;zobrazi panel
		ld	hl,(OORT2)		;ukazatel v buffroch je rovnaky ako ukazatel v paneli
		ld	(INPANEL1),hl		;ulozi posunuty ukazatel
		jp	main1			;a navrat

;Navrat do hlavneho programu so zobrazenim kurzora a pauzou
do_main:	call	show_cursor		;zobrazi kurzor
		call	wait_5_ints		;pocka 5 preruseni
		jp	main1			;a navrat

;Nacita polozky z adresara a skonvertuje ich na text:
;
;format poloziek
;00: identifikator
;01-02: cislo
;03-30: text (28)
;31: 0 
;
;input:	bc=cislo souboru od ktoreho bude vypis 
;	ix=ukazatel na buffer panel1/panel2
;
; !!! Toto asi mal byt univerzalny podporogram, na nacitanie adresarovej polozky
; !!! ale asi to nie je dobre. S inou adresarovou polozkou ako nultou to asi
; !!! nebude fungovat dobre, vid nizsie
;
read_directory:	push	bc			;odlozi vstupne premenne, v bc cislo suboru
		push	ix			;v ix je aktualne PANEL1

		ld	a,dos_kolkox		;sluzba KOLKOX, v DE vrati pocet adresarovych poloziek v aktualnom adresari 
		rst	#20			;BSDOS

		jp	nc,chdrv_pause		;ak je chyba, preco navrat cez pauzu na change_drive?
		ld	hl,0
		call	cp_hl_de		;ak je pocet poloziek 0
		call	z,de_to_32		;nastavi pocet adresarovych poloziek na 32.
						;wtf? nemoze byt: 	jr nz,blah
						;			ld de,32
						; 		blah:	ld (lendir1),de ???
		ld	(LENDIR1),de		;pocet adresarovych poloziek ulozi do premennej
		pop	ix			;vyzdvihne adresu buffra
		pop	bc			;vyzdvihne cislo suboru
		ld	a,32			;32 poloziek pre pripad prazdneho adresara
read_dir_1:	push	af			;odlozi pocet poloziek
		push	bc			;odlozi cislo suboru
		push	bc			;odlozi cislo suboru este raz pre next_item

						;vstup je nas ix=buffer, bc=cislo suboru
		ld	a,dos_getsub		;sluzba GETSUB, v buffri vrati 32 bajtovu adresarovu polozku suboru
		rst	#20			;BSDOS
						;zaroven vracia nc=chyba a z=neplatna adresarova polozka

		pop	bc			;vyzdvihne cislo suboru
		jp	nc,chdrv_pause		;ak dos_getsub dopadol zle, preco navrat cez pauzu na change_drive?
		call	z,bad_item		;ak je polozka neplatna, v buffri vytvori chybnu polozku
						;wtf2? nemoze byt:	jr nz,blabla
						;			xor a
						;			ld (ix+0),a
						;		blabla:	ld(ix+1),c ???
		ld	(ix+1),c		;do buffra ulozi cislo suboru
		ld	(ix+2),b
		ld	a,(ix+0)		;tu skontroluje typ polozky
		or	a
		jp	z,empty_item		;ak je chybna, pokracuje na vytvorenie popisu prazdnej polozky
		
						;tuto sa asi ma vytvarat popis adresara
		cp	#80			;!!! hmm, ak nie sme v nultej adresarovej polozke tak to nejak
		jp	z,dir_item		;!!! fungovat bude, ale asi to nie je dobre !!!
		
		ld	a,(ix+#05)		;prevod typu suboru na znaky?
		add	a,48			;funguje ale len pre 0-9
		ld	(wkspc_item),a
		push	ix
		pop	hl			;do hl si da adresu buffra			
		ld	de,6			
		add	hl,de			;posunie sa o 6 bytes vyssie (meno suboru?)
		ld	de,wkspc_item+2		;do de si da adresu, kde vo wkspc_item bude meno suboru
		ld	bc,10			;do bc ide 10 znakov (meno suboru)
rd_d_lp:	ld	a,(hl)			;v slucke po jednom cita znaky
		cp	32			;medzeru naradi pomlckou
		call	c,space2minus		;wtf3? opat by sa nedalo:	jr nc,houno
						;				ld a,'-'
						;			houno:	ld (de),a ???
		ld	(de),a			;a vlozi ich do wkspc_item na miesto
		inc	de
		cpi
		jp	pe,rd_d_lp

		ld	e,1			;vypis znakov bude prebiehat do pamate, nie na obrazovku
		ld	a,dos_sddx		;sluzba SDDX
		rst	#20			;BSDOS

		ld	l,(ix+#12)		;z headru v buffri vycita hodnotu start
		ld	h,(ix+#13)
		ld	iy,wkspc_item+14	;ukazatel nastavi do wkspc_item, kde je na to miesto
		call	dec2char16_j		;a zapise ju tam ako znaky
		ld	l,(ix+#18)		;dalej vycita dlzku suboru
		ld	h,(ix+#19)
		ld	e,(ix+#1A)
		ld	d,(ix+#1B)
		ld	iy,wkspc_item+21	;ukazatel nastavi do wkspc_item, kde je na to miesto
		call	dec2char32_j		;a zapise ju tam ako znaky
		ld	hl,wkspc_item		;zoberie si adresu wkspc_item
		jr	mv_item_to_buf		;a odskok na prenos polozky do bufferu

next_item:	xor	a			;ulozi nulu
		ld	(de),a			;ako oznacenie konca polozky
		ld	bc,32
		add	ix,bc			;posunie sa na dalsiu polozku v bufferi
		pop	bc			
		inc	bc
		pop	af
		dec	a
		jr	nz,read_dir_1		;a opakuje pre vsetky polozky, ktore su v adresari
		ret

;wtf2? v buffri vytvori chybnu polozku. nejde osetrit za jazdy?
bad_item:	xor	a
		ld	(ix+0),a
		ret

;do de da hodnotu 32, wtf? to nejde osetrit za jazdy?
de_to_32:	ld	de,32
		ret

;nastavi ukazatel na text prazdnej polozky
empty_item:	ld	hl,wkspc_emptitem
		jr	mv_item_to_buf		;pokracuje presunom

dir_item:	push	ix			;do hl si da adresu buffra
		pop	hl
		ld	de,6
		add	hl,de			;posunie sa o 6 bytes vyssie (meno adresara?)
		ld	de,wkspc_diritem+2	;do de si da adresu, kde vo wkspc_diritem bude meno adresara
		ld	bc,10			;10 znakov mena
dir_i_lp:	ld	a,(hl)			;a v slucke po jednom nacita znaky
		cp	32			;medzeru nahradzuje pomlckou
		call	c,space2minus
		ld	(de),a			;a zapisuje ich na miesto vo wkspc_diritem
		inc	de
		cpi
		jp	pe,dir_i_lp
		ld	hl,wkspc_diritem	;pokracuje presunom polozky do buffra
mv_item_to_buf: push	ix			;prehodi si do de
		pop	de			;adresu buffra
		inc	de			;posunie sa o tri pozicie vyssie
		inc	de
		inc	de			
		ld	bc,28			;a presunie tam 28 znakov
		ldir				;wkspc_item, alebo wkspc_diritem
		jp	next_item		;pokracuje na next_item, ale vola sa len odtialto, tak by mohlo byt tu

chdrv_pause:	call	wait_5_ints		;pocka 5 preruseni
		ld	b,6
chdrv_p_lp:	inc	sp			;6 krat podvihne stack (len balast?)
		djnz	chdrv_p_lp
		jp	change_drive		;navrat cez zmenu mechaniky v aktivnom paneli?

;wtf3? opat asi treba osetrit za jazdy
space2minus:	ld	a,'-'
		ret

;pracovne miesto kde sa tvoria textove polozky pre vypis v paneli
wkspc_item:	nop				;typ polozky
		db	" ----------  "		;predloha pre subory
		ds	5			;start adresa
		db	"  "
		ds	7			;dlzka suboru
wkspc_diritem:	db	"- ----------  <"	;predloha pre adresare
		db	"DIRECTORY>   "
wkspc_emptitem:	db	"- ----------   "	;predloha pre prazdnu polozku
		db	"   0        0"

;Vykreslovanie panelov
;input:	ix=polozka v bufferi odkial sa ma vykreslovat
;	draw_panel+1=stlpec ktory chceme vykreslovat
draw_panel:	ld	hl,2*256+2		;suradnice
		ld	b,16			;pocet poloziek
draw_panel_1:	push	bc			;odlozi si vsetko
		push	ix
		push	hl
		ld	b,(ix+2)		;zoberie cislo suboru z polozky v bufferi
		ld	c,(ix+1)
		call	OZNTEST			;skontroluje ci je oznaceny
		or	a
		jr	nz,file_is_marked	;ak ano, nastavi mu prislusnu farbu
		jr	file_not_markd		;ak nie, pokracuje normalne

file_is_marked:	pop	hl			;obnovi suradnice a polozky 
		pop	ix
		pop	bc
		push	bc			;znova ich uschova
		push	ix
		push	hl
		ld	a,(ix+0)		;zisti stav polozky (valid, deleted, empty)
		rla
		jr	nc,mrkd_del_empty	;oznaci cervenou ak je deleted, alebo empty
		ld	a,79			;inak ofarbi bielou
		jr	color_in

;subor je zmazany, alebo prazdny a je oznaceny
mrkd_del_empty:	ld	a,74			;aktualne cervena
		jr	color_in

;subor je zmazany, alebo prazdny a nie je oznaceny
nmrkd_del_empt:	ld	a,72			;aktualne cierna
		jr	color_in

file_not_markd:	pop	hl			;obnovi suradnice a polozky
		pop	ix
		pop	bc
		push	bc			;znova ich uschova
		push	ix
		push	hl
		ld	a,(ix+0)		;zisti stav polozky (valid, deleted, empty)
		rla
		jr	nc,nmrkd_del_empt	;oznaci ciernou
		ld	a,77			;inak je to bez oznacenia, aktualne svetlomodra
color_in:	push	hl			;odlozi si suradnice
		ex	af,af'
		call	pixel_address		;prepocita si zo suradnic vykreslovania polozku
		call	attr_address		;polohu atributov
		ex	af,af'
		ld	b,14			;a ofarbi 14 bajtov pod vykreslovanymi polozkami
color_in_lp:	ld	(hl),a
		inc	l
		djnz	color_in_lp
		pop	hl			;vyzdvihne si suradnice
		push	ix			;prehodi si buffer do de (pre potreby tlacovej rutiny)
		pop	de
		inc	de			;nastavi poziciu
		inc	de
		inc	de
		call	print64			;vykresli
		pop	hl			;obnovi si suradnice
		inc	h
		pop	ix
		ld	bc,32			;posunie sa na dalsiu polozku
		add	ix,bc
		pop	bc
		djnz	draw_panel_1		;a opakuje podla poctu poloziek
		ret

UPPER		call	hide_cursor
		ld	hl,0*256+1
		ld	a,3
		call	INV
		ld	ix,DATA
UPPER0		push	hl
		call	inkey
		pop	hl
UPPER1		cp	9
		jr	z,RIGHT
		cp	8
		jr	z,LEFT
		cp	13
		jp	z,ENTER
		call	ESCAPE
		jp	nc,ESC
		jr	UPPER0
		nop
DATA		db	1,4,10,21,28
		db	3,6,11,7,9
RIGHT		ld	a,(ix+5)
		call	INV
		inc	ix
		ld	l,(ix+0)
		ld	a,l
		cp	3
		call	z,BE
		ld	a,(ix+5)
		call	INV
		call	wait_5_ints
		jr	UPPER0
LEFT		ld	a,(ix+5)
		call	INV
		dec	ix
		ld	l,(ix+0)
		ld	a,l
		or	a
		call	z,EN
		ld	a,(ix+5)
		call	INV
		call	wait_5_ints
		jr	UPPER0
BE		ld	l,1
		ld	ix,DATA
		ret
EN		ld	l,28
		ld	ix,DATA+4
		ret
ESC		ld	a,(ix+5)
		call	INV
		jp	main
ENTER		ld	(IXPOS),ix
		ld	(HLPOS),hl
		ld	a,l
		cp	4
		jp	z,MNU2
		cp	10
		jp	z,MNU3
		cp	21
		jp	z,MNU4
		cp	28
		jp	z,MNU5

MNU1		ld	hl,1*256+0
		ld	de,6*256+8
		call	IN
		exx
		ld	hl,2*256+1
		ld	de,TMNU1
		ld	a,15
		ld	b,4
		call	PMNU
		exx
		call	MENU1
		call	BAR
		cp	1
		jp	z,ABOUT
		cp	2
		jp	z,SYSTEM
		cp	3
		jp	z,OPTIONS
		jp	EXIT

TMNU1		db	" About        "
		nop
		db	" System Info  "
		nop
		db	" Options      "
		nop
		db	" Exit       X "
		nop

MNU2		ld	hl,1*256+2
		ld	de,10*256+11
		call	IN
		exx
		ld	hl,2*256+5
		ld	de,TMNU2
		ld	b,8
		ld	a,21
		call	PMNU
		exx
		call	MENU1
		call	BAR
		cp	1
		jp	z,VIEW
		cp	2
		jp	z,COPY
		cp	5
		jp	z,DELETE
		cp	6
		jp	z,RENAME
		cp	8
		jp	z,UNDELETE
		jp	main

TMNU2		db	" View          "
		db	"   3 "
		nop
		db	" Copy          "
		db	"   5 "
		nop
		db	" Move          "
		db	"   6!"
		nop
		db	" Search        "
		db	"   7!"
		nop
		db	" Delete        "
		db	"   8 "
		nop
		db	" Rename        "
		db	"   9 "
		nop
		db	" Change Addr   "
		db	"   A!"
		nop
		db	" Undelete      "
		db	"   U "
		nop

MNU3		ld	hl,1*256+5
		ld	de,5*256+8
		call	IN
		exx
		ld	hl,2*256+11
		ld	de,TMNU3
		ld	a,15
		ld	b,3
		call	PMNU
		exx
		call	MENU1
		call	BAR
		cp	1
		jp	z,main
		cp	2
		jp	z,REDISK
		jp	SETTIME

TMNU3		db	" Diskcopy    !"
		nop
		db	" Rename Disk  "
		nop
		db	" Set Time     "
		nop

MNU4		ld	hl,1*256+10
		ld	de,9*256+13
		call	IN
		exx
		ld	hl,2*256+21
		ld	de,TMNU4
		ld	a,25
		ld	b,7
		call	PMNU
		exx
		call	MENU1
		call	BAR
		cp	1
		jp	z,PRESS
		cp	2
		jp	z,OZNMASK
		cp	3
		jp	z,OZNALL
		cp	4
		jp	z,ODZNALL
		cp	5
		jp	z,UZNALL
		cp	6
		jp	z,II
		jp	main


TMNU4		db	" Press Director"
		db	"y      P "
		nop
		db	" Select Group  "
		db	"    Edit "
		nop
		db	" Select All    "
		db	"       + "
		nop
		db	" Deselect All  "
		db	"       - "
		nop
		db	" Swap Selection"
		db	"       * "
		nop
		db	" Panel info    "
		db	"       I "
		nop
		db	" Nothing...   !"
		db	"         "
		nop

MNU5		ld	hl,1*256+14
		ld	de,6*256+13
		call	IN
		exx
		ld	hl,2*256+29
		ld	de,TMNU5
		ld	b,4
		ld	a,25
		call	PMNU
		exx
		call	MENU1
		call	BAR
		cp	1
		jr	z,RR
		cp	2
		jp	z,change_dir
		cp	3
		jp	z,chnge_drv_left
		cp	4
		jp	z,chnge_drv_rght
		jp	main

RR		call	refresh_pane
		jp	main1
TMNU5		db	" Re-read       "
		db	"       R "
		nop
		db	" Change Dir    "
		db	"       D "
		nop
		db	" Change Drive L"
		db	"eft    1 "
		nop
		db	" Change Drive R"
		db	"ight   2 "
		nop

BAR		inc	h
		ld	a,d
		ld	(COMP+1),a
		dec	a
		ld	(CH1+1),a
		sla	l
		inc	l
		ld	a,e
		dec	a
		rla
		ld	(INVP+1),a
		call	INV
		call	wait_5_ints
BAR0		push	hl
		call	inkey
		pop	hl
		cp	11
		jr	z,UP
		cp	10
		jr	z,DOWN
		cp	13
		jr	z,CHOICE
		cp	8
		jr	z,RT
		cp	9
		jr	z,RT
		call	ESCAPE
		jp	nc,RT
		jr	BAR0
UP		call	INVP
		dec	h
		ld	a,h
		cp	1
		call	z,CH1
		call	INVP
		call	wait_5_ints
		jr	BAR0
CH1		ld	h,0
		ret
DOWN		call	INVP
		inc	h
		ld	a,h
COMP		cp	0
		call	z,CH2
		call	INVP
		call	wait_5_ints
		jr	BAR0
CH2		ld	h,2
		ret
INVP		ld	a,0
		jp	INV
RT		inc	sp
		inc	sp
		push	af
		call	OUT
		pop	af
		ld	ix,(IXPOS)
		ld	hl,(HLPOS)
		call	wait_5_ints
		cp	32
		jp	z,UPPER0
		jp	UPPER1
CHOICE		ld	a,h
		dec	a
		push	af
		call	OUT
		ld	hl,(HLPOS)
		ld	ix,(IXPOS)
		ld	a,(ix+5)
		call	INV
		pop	af
		jp	wait_5_ints

PMNU		ld	(TDH+1),a
PMNU0		push	bc
		push	hl
		push	de
		call	print64
		pop	hl
TDH		ld	bc,0
		add	hl,bc
		ex	de,hl
		pop	hl
		inc	h
		pop	bc
		djnz	PMNU0
		ret
;------------------------------
ABOUT		ld	hl,10*256+8
		ld	de,5*256+16
		call	IN
		exx
		ld	hl,11*256+17
		ld	de,ABTXT2
		ld	b,3
		ld	a,31
		call	PMNU
		exx
		ld	a,120
		call	MENU2
		ld	hl,10*256+28
		ld	de,ABTXT1
		call	print64
		call	AKEY
		call	OUT
		jp	main
ABTXT1		db	"About FC"
		nop
ABTXT2		db	" Fast Commander"
		db	" Version 0.1 D "
		nop
		db	"      K3L Corp."
		db	" 1996-2000     "
		nop
		db	"         Code b"
		db	"y EYE          "
		nop

OPTIONS		ld	hl,10*256+10
		ld	de,5*256+12
		call	IN
		exx
		ld	hl,11*256+21
		ld	de,OPTXT2
		ld	b,3
		ld	a,23
		call	PMNU
		exx
		ld	a,120
		call	MENU2
		ld	hl,10*256+28
		ld	de,OPTXT1
		call	print64
		ld	hl,10*256+35
		ld	a,205
		call	char64
		ld	ix,OPT
		ld	h,11
		bit	0,(ix+0)
		call	nz,PX
		ld	h,12
		bit	1,(ix+0)
		call	nz,PX
		ld	h,13
		bit	2,(ix+0)
		call	nz,PX
		ld	a,(OPT)
		ld	xh,a
		ld	hl,11*256+25
		ld	a,17
		call	INV
		ld	h,11
TK		push	hl
		call	inkey
		pop	hl
		cp	11
		jr	z,NNN
		cp	10
		jr	z,MMM
		cp	32
		jr	z,FLOP
		cp	13
		jr	z,HAPPY
		call	ESCAPE
		jr	nc,NO
		jr	TK
HAPPY		ld	a,xh
		ld	(OPT),a
NO		call	OUT
		jp	main
FLOP		ld	a,h
		sub	11
		add	a,a
		add	a,a
		add	a,a
		add	a,71
		ld	(MDF3+1),a
		add	a,64
		ld	(MDF1+1),a
		add	a,64
		ld	(MDF2+1),a
		ld	a,xh
MDF3		bit	0,a
		jr	z,IH
		ld	l,23
		push	hl
		call	REM
		pop	hl
		ld	a,xh
MDF1		res	0,a
		ld	xh,a
		call	wait_5_ints
		jr	TK
IH		call	PX
		ld	a,xh
MDF2		set	0,a
		ld	xh,a
		call	wait_5_ints
		jr	TK
REM		call	pixel_address
		ld	b,8
REM0		ld	a,(hl)
		and	240
		ld	(hl),a
		inc	h
		djnz	REM0
		ret
NNN		call	ARAB
		dec	h
		ld	a,h
		cp	10
		call	z,NNN1
		jr	ARAB0
NNN1		ld	h,13
		ret
MMM		call	ARAB
		inc	h
		ld	a,h
		cp	14
		call	z,MMM1
		jr	ARAB0
MMM1		ld	h,11
		ret
ARAB		ld	l,25
		ld	a,17
		jp	INV
ARAB0		call	ARAB
		call	wait_5_ints
		jp	TK
PX		ld	a,'X'
		ld	l,23
		push	hl
		call	char64
		pop	hl
		ret
OPT		db	%00000110
OPTXT1		db	"Options"
		nop
OPTXT2		db	" ( ) Beep after"
		db	" Copy  "
		nop
		db	" ( ) Clock     "
		db	"       "
		nop
		db	" ( ) Harddisk E"
		db	"nable  "
		nop

EXIT:		ld	hl,msg_exit_dos		;adresa textu
		ld	a,dos_messx		;sluzba MESSX		
		rst	#20			;BSDOS

		jr	nc,BACK			;navrat do programu ak bola stlacena medzera
		jp	RETDOS

BACK		call	OUT
		jp	main

msg_exit_dos:	db	"Exit to Dos ?"
		db	#00,#C9

CHANGE		ld	a,dos_getcst		;sluzba GETCST
		rst	#20			;BSDOS

		call	activate_drive		
		cp	2
		jr	nz,CHREP
		ld	hl,BOOT
		ld	de,1
		call	read_sector
		cp	1
		jr	z,CHANGE
		or	a
		jr	z,CHABORT
		ld	de,JIST1		;
		ld	hl,BOOT
		ld	bc,1024
OPICE		ld	a,(de)
		cp	(hl)
		jr	nz,CHREP
		inc	hl
		inc	de
		dec	bc
		ld	a,c
		or	b
		jr	nz,OPICE
		ret

CHREP:		ld	hl,msg_disk_chgd	;adresa textu
		ld	a,dos_messx		;sluzba MESSX
		rst	#20			;BSDOS

		jr	nc,CHABORT		;navrat ak bola stlacena medzera
		pop	hl
		call	refresh_pane		;inak znovunacitanie panelov
		jp	main1
CHABORT:	pop	hl
		jp	main

msg_disk_chgd:	db	"Disk changed !"
		db	#00,#C9

SYSTEM		di
		ld	a,233
		ld	(interrupt),a
		ld	hl,CPU1
		ei
		halt
CPU1		ei
		ld	hl,CPU2
		ld	bc,0
CPU0		inc	bc
		jr	CPU0
CPU2		pop	hl
		pop	hl
		ld	a,243
		ld	(interrupt),a
		ei
LN		equ	$-SYSTEM
		ld	(KOEF2),bc
		ld	hl,SYSTEM
		ld	de,FASTMEM
		ld	bc,LN
		ldir
		ld	hl,FASTMEM+11
		ld	(FASTMEM+7),hl
		ld	hl,FASTMEM+21
		ld	(FASTMEM+13),hl
		ld	a,201
		ld	(de),a
		call	FASTMEM
		ld	(KOEF1),bc
		ld	hl,6*256+7
		ld	de,12*256+19
		call	IN
		push	hl
		push	de
		ld	hl,7*256+16
		ld	de,STEXT2
		ld	b,10
		ld	a,16
		call	PMNU

		ld	e,1			;vypis znakov bude prebiehat do pamate, nie na obrazovku
		ld	a,dos_sddx		;sluzba SDDX
		rst	#20			;BSDOS

		ld	de,(KOEF2)
		ld	hl,3614
		call	cp_hl_de
		ld	de,COMP3
		jr	c,DONE
		ld	de,(KOEF1)
		ld	hl,3935
		call	cp_hl_de
		exx
		ld	de,COMP2
		jr	c,DONE
		exx
		ld	hl,3878
		call	cp_hl_de
		ld	de,COMP1
		jr	c,DONE
		ld	de,COMP4
DONE		ld	hl,7*256+31
		call	print64
		ld	de,(KOEF1)
		ld	b,9
		call	NAS
		push	hl
		call	dec2char16
		ld	hl,NUM
		ld	de,SPEED
		ldi
		ld	a,46
		ld	(de),a
		inc	de
		ldi
		ldi
		pop	hl
		ld	de,0
		sla	l
		rl	h
		rl	e
		ld	bc,47
		add	hl,bc
		call	dec2char32
		ld	hl,NUM
		ld	de,SPEED+8
		ld	bc,5
		ldir
		ld	de,(KOEF2)
		ld	b,18
		call	NAS
		ld	de,47
		add	hl,de
		call	dec2char16
		ld	hl,NUM
		ld	de,SPEED+14
		ld	bc,5
		ldir
		ld	hl,8*256+31
		ld	de,SPEED
		call	print64
		ld	hl,0
		ld	c,8
SRAM0		ld	a,96
		or	c
		out	(23),a
		ld	e,(hl)
		ld	a,e
		cpl
		ld	(hl),a
		cp	(hl)
		jr	nz,SRAM1
		ld	(hl),e
		ld	a,c
		add	a,8
		ld	c,a
		cp	32
		jr	nz,SRAM0
SRAM1		ld	l,c
		add	hl,hl
		add	hl,hl
		add	hl,hl
		add	hl,hl
		ld	a,97
		out	(23),a
		call	dec2char16
		ld	hl,NUM
		ld	de,SRAM+3
		ld	bc,3
		ldir
		ld	a,(MEM128)
		cp	128
		jr	z,SYS_128
		ld	hl,TX_48
		jr	SYS128
SYS_128		ld	hl,TX_128
SYS128		ld	de,SRAM+13
		ld	bc,3
		ldir
		ld	hl,9*256+31
		ld	de,SRAM
		call	print64
		ld	de,NONE
		ld	l,0
RTC0		ld	bc,5*256+3
RTC1		in	a,(c)
		and	15
		cp	10
		jr	nc,NORTC
		djnz	RTC1
		dec		l
		jr	nz,RTC0
		ld	de,DET
NORTC		ld	hl,10*256+31
		call	print64
		ld	bc,65533
		ld	a,7
		ld	e,63
		out	(c),a
		ld	b,191
		out	(c),e
		ld	b,255
		in	a,(c)
		cp	e
		ld	de,NONE
		jr	nz,NOTAY
		ld	de,DET
NOTAY		ld	hl,11*256+31
		call	print64
		ld	ix,DRV1
		ld	hl,12*256+31
		ld	b,4
DRVS		push	bc
		push	hl
		ld	a,(ix+0)
		or	a
		ld	de,NONE
		jr	z,NP
		bit	1,a
		ld	de,DD
		jr	z,NHD
		ld	de,HD
NHD		push	de
		ld	e,(ix+1)
		push	ix
		call	dec2char8
		pop	ix
		pop	de
		ld	a,(NUM)
		ld	(de),a
		inc	de
		ld	a,(NUM+1)
		ld	(de),a
		dec	de
NP		call	print64
		pop	hl
		pop	bc
		inc	h
		inc	ix
		inc	ix
		djnz	DRVS
		ld	hl,(VER)
		call	dec2char16
		ld	hl,NUM
		ld	de,VERS
		ldi
		ldi
		ldi
		ld	hl,16*256+31
		ld	de,VERS
		call	print64
		pop	de
		pop	hl
		ld	a,120
		call	MENU2
		ld	hl,6*256+26
		ld	de,STEXT1
		call	print64
		ld	hl,6*256+26
		ld	a,205
		call	char64
		call	AKEY
		call	OUT
		call	wait_5_ints
		jp	main
PAGE		push	af
		ld	a,%01100000
		or	c
		out	(23),a
		pop	af
		ret
STEXT1		db	" System Info"
		nop
STEXT2		db	"Computer type: "
		nop
		db	"    CPU Speed: "
		nop
		db	"  Memory size: "
		nop
		db	"RTC Processor: "
		nop
		db	" AY Processor: "
		nop
		db	"      Drive 1: "
		nop
		db	"      Drive 2: "
		nop
		db	"      Drive 3: "
		nop
		db	"      Drive 4: "
		nop
		db	"  DOS Version: "
		nop
COMP1		db	"ZX Spectrum/+  "
		db	"     "
		nop
COMP2		db	"ZX Spectrum 128"
		db	"+/+2 "
		nop
COMP3		db	"ZX Spectrum +2A"
		db	"/+3  "
		nop
COMP4		db	"Didaktik M     "
		db	"     "
		nop
DET		db	"Detected       "
		db	"     "
		nop
NONE		db	"None           "
		db	"     "
		nop
SRAM		db	"MB     K, ZX   "
		db	"     "
		nop
SPEED		db	"    Mhz      / "
		db	"     "
		nop
VERS		db	"               "
		db	"     "
		nop
DD		db	"   tracks, DD  "
		db	"     "
		nop
HD		db	"   tracks, HD  "
		db	"     "
		nop
TX_48		db	"48 "
TX_128		db	"128"


PRESS		call	CHANGE
		ld	hl,10*256+8
		ld	de,4*256+16
		call	IN
		exx
		ld	hl,11*256+17
		ld	de,PRTXT
		ld	b,2
		ld	a,31
		call	PMNU
		exx
		ld	a,120
		call	MENU2

		ld	a,dos_utrasx		;sluzba UTRASX
		rst	#20			;BSDOS

		call	OUT
		call	refresh_pane
		jp	main1
PRTXT		db	"     Deflating "
		db	"Directory      "
		nop
		db	"         Please"
		db	" Wait          "
		nop

OZN		ld	bc,(FILE1)
		call	OZNSWAP
		or	a
		jr	z,OZNNE
		ld	hl,(POZICE1)
		call	pixel_address
		call	attr_address
		ld	b,14
OZNJO		set	1,(hl)
		inc	l
		djnz	OZNJO
		jp	cursor_down
OZNNE		ld	hl,(POZICE1)
		call	pixel_address
		call	attr_address
		ld	b,14
OZNN		res	1,(hl)
		inc	l
		djnz	OZNN
		jp	cursor_down
OZNCHAN		ld	hl,49152
		ld	ix,57344
		ld	de,8190
OZNCHAN1	ld	a,(hl)
		ex	af,af'
		ld	a,(ix+0)
		ld	(hl),a
		ex	af,af'
		ld	(ix+0),a
		inc	ix
		inc	hl
		dec	de
		ld	a,d
		or	e
		jr	nz,OZNCHAN1
		ret
OZNDEL1		ld	hl,49152
		ld	de,49153
		ld	bc,8189
		ld	(hl),0
		ldir
		ret
OZNDEL2		ld	hl,57344
		ld	de,57345
		ld	bc,8189
		ld	(hl),0
		ldir
		ret

OZNTEST		call	OZNFIND
		or	a
		jr	z,OZNTB0
		ld	a,1
OZNT		sla	a
		djnz	OZNT
		jr	OZNT1
OZNTB0		ld	a,1
OZNT1		ld	b,a
		ld	a,(hl)
		and	b
		ret

OZNSWAP		push	bc
		call	OZNFIND
		or	a
		jr	z,OZNSB0
		ld	a,1
OZNS		sla	a
		djnz	OZNS
		jr	OZNS1
OZNSB0		ld	a,1
OZNS1		ld	b,a
		ld	a,(hl)
		xor	b
		ld	(hl),a
		and	b
		pop	bc
		ret

OZNFIND		ld	d,b
		ld	e,c
		srl	d
		rr	e
		srl	d
		rr	e
		srl	d
		rr	e
		ld	hl,49152
		add	hl,de
		ld	a,c
		and	%111
		ld	b,a
		ret

OZNALL		call	CHANGE
		ld	hl,(LENDIR1)
		ld	a,h
		or	l
		jp	z,main
		ld	hl,10*256+8
		ld	de,5*256+16
		call	IN
		exx
		ld	hl,11*256+17
		ld	de,OZNTXT
		ld	b,3
		ld	a,31
		call	PMNU
		exx
		ld	a,120
		call	MENU2
		ld	bc,1
NXTALL		push	bc
		call	PROZENT

		ld	ix,FASTMEM		;adresa buffra
		ld	a,dos_getsub		;sluzba GETSUB
		rst	#20			;BSDOS

		jr	z,OUTALL
		pop	bc
		ld	a,(FASTMEM)
		rla
		jr	c,NALL
ZNALL		call	OZNSWAP
		jr	nz,ZNALL
NXALL		inc	bc
		ld	hl,(LENDIR1)
		call	cp_hl_bc
		jr	nz,NXTALL
		push	bc
OUTALL		pop	bc
		call	OUT
		jp	cursor_pos_cnt
NALL		call	OZNSWAP
		jr	z,NALL
		jr	NXALL

OZNTXT		db	"      Selecting"
		db	" All Files     "
		nop
		db	"         Please"
		db	" Wait          "
		nop
		db	"               "
		db	"               "
		nop

ODZNALL		call	CHANGE
		call	OZNDEL1
		jp	cursor_pos_cnt

UZNALL		call	CHANGE
		ld	hl,(LENDIR1)
		ld	a,h
		or	l
		jp	z,main
		ld	hl,10*256+8
		ld	de,5*256+16
		call	IN
		exx
		ld	hl,11*256+17
		ld	de,UZNTXT
		ld	b,3
		ld	a,31
		call	PMNU
		exx
		ld	a,120
		call	MENU2
		ld	bc,1
NXTULL		push	bc
		call	PROZENT

		ld	ix,FASTMEM		;adresa buffra
		ld	a,dos_getsub		;sluzba GETSUB
		rst	#20			;BSDOS

		jr	z,OUTULL
		pop	bc
		ld	a,(FASTMEM)
		rla
		jr	nc,NULL
		call	OZNSWAP
NXULL		inc	bc
		ld	hl,(LENDIR1)
		call	cp_hl_bc
		jr	nz,NXTULL
		push	bc
OUTULL		pop	bc
		call	OUT
		jp	cursor_pos_cnt
NULL		call	OZNSWAP
		or	a
		jr	nz,NULL
		jr	NXULL
UZNTXT		db	"      Changing "
		db	"Selection      "
		nop
		db	"         Please"
		db	" Wait          "
		nop
		db	"               "
		db	"               "
		nop

OZNMASK		call	CHANGE
		call	MASK
		call	CHANGE
		ld	hl,(LENDIR1)
		ld	a,h
		or	l
		jp	z,main
		ld	hl,10*256+8
		ld	de,5*256+16
		call	IN
		exx
		ld	hl,11*256+17
		ld	de,MTXT
		ld	b,3
		ld	a,31
		call	PMNU
		exx
		ld	a,120
		call	MENU2
		ld	bc,1
NXTM		push	bc
		call	PROZENT

		ld	ix,FASTMEM		;adresa buffra
		ld	a,dos_getsub		;sluzba GETSUB
		rst	#20			;BSDOS

		jr	z,OUTM
		pop	bc
		ld	a,(FASTMEM)
		rla
		jr	nc,NM
		push	bc
		call	SETIN
		ld	de,TEXT
		ld	a,(CR)
		ld	c,a
		or	a
		jr	z,NXM
		call	WILDCHAR
		pop	bc
		jr	nz,NXM
ZNM		call	OZNSWAP
		or	a
		jr	z,ZNM
NXM		inc	bc
		ld	hl,(LENDIR1)
		call	cp_hl_bc
		jr	nz,NXTM
		push	bc
OUTM		pop	bc
		call	OUT
		jp	cursor_pos_cnt
NM		call	OZNSWAP
		or	a
		jr	nz,NM
		jr	NXM
MTXT		db	" Selecting Mask"
		db	"ed File Block  "
		nop
		db	"         Please"
		db	" Wait          "
		nop
		db	"               "
		db	"               "
		nop

;de=maska, hl=jmeno
;c=delka masky, b=delka jmena
;out: z =, nz <>
WILDCHAR	inc	c
		inc	b
		ld	a,1
		push	af
		jr	WCST
WCZP		pop	af
		pop	af
		pop	af
WCHVOP2		dec	c
		ret	z
		ld	a,(de)
		inc	de
		cp	'*'
		jr	z,WCHVOP2
		dec	de
		inc	c
WCHVOP		push	bc
WCST		push	hl
		push	de
WCHVOP4		ld	a,(de)
		inc	de
		dec	c
		jr	z,KON5
		cp	'*'
		jr	z,WCZP
		dec	b
		jr	z,KON3
		cp	'?'
		jr	z,WCHVDAL2
		cp	(hl)
WCHVDAL2	inc	hl
		jr	z,WCHVOP4
WCHVZN2		pop	de
		pop	hl
		pop	bc
		inc	hl
		djnz	WCHVOP
		dec	b
		ret
KON3		dec	b
		jr	WCHVZP2
KON5		dec	b
		jr	nz,WCHVZN2
WCHVZP2		pop	hl
		pop	hl
		pop	hl
		ret

SETIN		ld	hl,FASTMEM+16
		ld	a,255
		ld	(FASTMEM+5),a
SETNE		dec	hl
		ld	a,(hl)
		cp	32
		jr	z,NSETHO
		cp	0
		jr	z,NSETHO
		jr	SETHO
NSETHO		cp	255
		jr	nz,SETNE
SETHO		ld	de,FASTMEM+5
		or	a
		sbc	hl,de
		ld	b,l
		ld	hl,FASTMEM+6
		ret

MASK		ld	hl,10*256+8
		ld	de,5*256+16
		call	IN
		exx
		ld	hl,11*256+17
		ld	de,MATXT1
		call	print64
		ld	hl,12*256+17
		ld	de,MATXT2
		call	print64
		ld	hl,13*256+17
		ld	de,MATXT3
		call	print64
		exx
		ld	a,120
		call	MENU2
		ld	hl,13*256+27
		ld	de,8315
		ld	iyl,11
		call	INTXT
		jr	nc,NMASK
		ld	hl,TEXT
		ld	de,FASTMEM+6
		ld	bc,10
		ldir
		call	SETIN
		ld	a,b
		ld	(CR),a
		call	OUT
		ld	de,TEXT
		ld	a,(CR)
		ld	c,a
		ret
CR		nop
NMASK		pop	hl
		call	OUT
		call	wait_5_ints
		jp	main
MATXT1		db	"         Enter "
		db	"New Mask:      "
		nop
MATXT2		db	"   ( Wildcards "
		db	"Are * And ? )  "
		nop
MATXT3		db	"               "
		db	"               "
		nop

II		call	CHANGE
		call	INFO

		ld	e,1			;vypis znakov bude prebiehat do pamate, nie na obrazovku
		ld	a,dos_sddx		;sluzba SDDX
		rst	#20			;BSDOS

		ld	iy,SFIL
		ld	hl,(STO)
		call	dec2char16_j
		ld	iy,SSEC
		ld	hl,(SLEN1)
		ld	de,(SLEN2)
		call	dec2char32_j
		ld	iy,TTOT
		ld	hl,(TLEN1)
		ld	de,(TLEN2)
		call	dec2char32_j
		ld	iy,STOT
		ld	hl,(TOT)
		call	dec2char16_j
		ld	iy,STOI
		ld	hl,(LENDIR1)
		call	dec2char16_j
		ld	a,(draw_panel+1)
		sub	2
		srl	a
		ld	hl,10*256+0
		ld	l,a
		ld	de,7*256+16
		call	IN
		exx
		ld	a,(draw_panel+1)
		ld	hl,11*256+0
		ld	l,a
		ld	de,INFPAN
		ld	b,5
		ld	a,31
		call	PMNU
		exx
		ld	a,120
		call	MENU2
		call	AKEY
		call	OUT
		jp	cursor_pos_cnt

INFO		ld	hl,0
		ld	(STO),hl
		ld	(TOT),hl
		ld	(SLEN1),hl
		ld	(SLEN2),hl
		ld	(TLEN1),hl
		ld	(TLEN2),hl
		ld	hl,(LENDIR1)
		ld	a,h
		or	l
		ret	z
		ld	hl,10*256+8
		ld	de,5*256+16
		call	IN
		exx
		ld	hl,11*256+17
		ld	de,INFTXT
		ld	b,3
		ld	a,31
		call	PMNU
		exx
		ld	a,120
		call	MENU2
		ld	bc,1
NXTINFO		push	bc
		call	PROZENT

		ld	ix,FASTMEM		;adresa buffra
		ld	a,dos_getsub		;sluzba GETSUB
		rst	#20			;BSDOS

		jr	z,OUTINFO
		pop	bc
		ld	a,(FASTMEM)
		rla
		jr	nc,NINFO
ZINFO		push	bc
		ld	hl,(TOT)
		inc	hl
		ld	(TOT),hl
		ld	hl,(FASTMEM+#18)
		ld	de,(FASTMEM+#1A)

		ld	a,dos_howsec		;sluzba HOWSEC
		rst	#20			;BSDOS

		ld	hl,(TLEN1)
		ld	de,(TLEN2)

		ld	a,dos_add32		;sluzba ADD32
		rst	#20			;BSDOS

		ld	(TLEN1),hl
		ld	(TLEN2),de
		pop	bc
		push	bc
		call	OZNTEST
		pop	bc
		or	a
		jr	z,NEINCINF
		push	bc
		ld	hl,(STO)
		inc	hl
		ld	(STO),hl
		ld	hl,(FASTMEM+#18)
		ld	de,(FASTMEM+#1A)

		ld	a,dos_howsec		;sluzba HOWSEC
		rst	#20			;BSDOS

		ld	hl,(SLEN1)
		ld	de,(SLEN2)

		ld	a,dos_add32		;sluzba ADD32
		rst	#20			;BSDOS

		ld	(SLEN1),hl
		ld	(SLEN2),de
		pop	bc
NEINCINF		inc	bc
		ld	hl,(LENDIR1)
		call	cp_hl_bc
		jr	nz,NXTINFO
		push	bc
OUTINFO		pop	bc
		call	OUT
		ret
NINFO		call	OZNSWAP
		jr	nz,NINFO
		jr	NEINCINF
STO		dw	0
TOT		dw	0
SLEN1		dw	0
SLEN2		dw	0
TLEN1		dw	0
TLEN2		dw	0
INFTXT		db	"       Checking"
		db	" files         "
		nop
		db	"         Please"
		db	" Wait          "
		nop
		db	"               "
		db	"               "
		nop
INFPAN		db	" Selected files"
		db	" : "
SFIL		db	"            "
		nop
		db	" Selected kB : "
		db	" "
SSEC		db	"              "
		nop
		db	" Total Items : "
		db	"   "
STOI		db	"            "
		nop
		db	" Existing files"
		db	" : "
STOT		db	"            "
		nop
		db	" Total kB :	"
		db	" "
TTOT		db	"              "
		nop


DELETE		ld	hl,(LENDIR1)
		ld	a,h
		or	l
		jp	z,main
		ld	bc,1
FDEL		push	bc
		call	OZNTEST
		pop	bc
		jr	nz,DELVIC
		inc	bc
		ld	hl,(LENDIR1)
		call	cp_hl_bc
		jr	nz,FDEL
		jp	DELJEDEN
DELVIC		call	DELREP
		ld	hl,0
		xor	a
		ld	(PROCIS),hl
		ld	(INTFRST),hl
		ld	(INTERVAL),a
		call	CHANGE
		ld	hl,10*256+8
		ld	de,5*256+16
		call	IN
		exx
		ld	hl,11*256+17
		ld	de,DETXT
		ld	b,3
		ld	a,31
		call	PMNU
		exx
		ld	a,120
		call	MENU2
		ld	bc,1
NXTD		push	bc
		call	PROZENT

		ld	ix,FASTMEM		;adresa buffra
		ld	a,dos_getsub		;sluzba GETSUB
		rst	#20			;BSDOS

		jr	z,OUTD
		pop	bc
		ld	a,(FASTMEM)
		rla
		ld	a,(INTERVAL)
		jr	nc,NDL
		push	bc
		call	OZNTEST
		ld	a,(INTERVAL)
		pop	bc
		jr	z,NDL
		or	a
		jr	nz,ND
		ld	(INTFRST),bc
		inc	a
		ld	(INTERVAL),a
ND		inc	bc
		ld	hl,(LENDIR1)
		call	cp_hl_bc
		jr	nz,NXTD
		push	bc
OUTD		pop	bc
		ld	a,(INTERVAL)
		or	a
		jr	z,OUTDD
		dec	bc
		ld	h,b
		ld	l,c
		ld	bc,(INTFRST)

		ld	a,dos_erasix		;sluzba ERASIX
		rst	#20			;BSDOS

OUTDD		call	OUT
		call	refresh_pane
		jp	main1
NDL		or	a
		jr	z,ND
		xor	a
		ld	(INTERVAL),a
		push	bc
		dec	bc
		ld	h,b
		ld	l,c
		ld	bc,(INTFRST)

		ld	a,dos_erasix		;sluzba ERASIX
		rst	#20			;BSDOS

		pop	bc
		jr	ND
INTERVAL	nop
INTFRST		dw	0
PROCIS		dw	0
DETXT		db	"         Deleti"
		db	"ng Files       "
		nop
		db	"         Please"
		db	" Wait          "
		nop
		db	"               "
		db	"               "
		nop

DELJEDEN	ld	bc,(FILE1)
		call	TDEL
		jp	nc,main
		call	DELREP
		call	CHANGE
		ld	bc,(FILE1)

		ld	a,dos_erasex		;sluzba ERASEX
		rst	#20			;BSDOS

		call	refresh_pane
		jp	main1

DELREP:		ld	hl,delete_it		;adresa textu
		ld	a,dos_messx		;sluzba MESSX
		rst	#20			;BSDOS

		jr	nc,DELABORT		;navrat ak bola stlacena medzera
		ret

DELABORT:	pop	hl
		jp	main

delete_it:	db	" Delete it ?  "
		db	#00,#C9

;in:bc-file
;out:je(c)/neni(nc)
;meni:FASTMEM
TDEL		ld	ix,FASTMEM		;adresa buffra
		ld	a,dos_getsub		;sluzba GETSUB
		rst	#20			;BSDOS

		ld	a,(FASTMEM)
		rla
		ret

UNDELETE	call	CHANGE
		ld	hl,(LENDIR1)
		ld	a,h
		or	l
		jp	z,main
		ld	bc,1
FUNDEL		push	bc
		call	OZNTEST
		pop	bc
		jr	nz,UNVIC
		inc	bc
		ld	hl,(LENDIR1)
		call	cp_hl_bc
		jr	nz,FUNDEL
		jp	UNJEDEN
UNVIC		ld	hl,0
		xor	a
		ld	(INTFRST),hl
		ld	(INTERVAL),a
		call	CHANGE
		ld	hl,10*256+8
		ld	de,5*256+16
		call	IN
		exx
		ld	hl,11*256+17
		ld	de,UNTXT
		ld	b,3
		ld	a,31
		call	PMNU
		exx
		ld	a,120
		call	MENU2
		ld	bc,1
NXTU		push	bc
		call	PROZENT

		ld	ix,FASTMEM		;adresa buffra
		ld	a,dos_getsub		;sluzba GETSUB
		rst	#20			;BSDOS

		jr	z,OUTU
		pop	bc
		ld	a,(FASTMEM)
		rla
		ld	a,(INTERVAL)
		jp	c,NUN
		push	bc
		call	OZNTEST
		ld	a,(INTERVAL)
		pop	bc
		jr	z,NUN
		or	a
		jr	nz,NU
		ld	(INTFRST),bc
		inc	a
		ld	(INTERVAL),a
NU		inc	bc
		ld	hl,(LENDIR1)
		call	cp_hl_bc
		jr	nz,NXTU
		push	bc
OUTU		pop	bc
		ld	a,(INTERVAL)
		or	a
		jr	z,OUTUU
		dec	bc
		ld	h,b
		ld	l,c
		ld	bc,(INTFRST)

		ld	a,dos_unerix		;sluzba UNERIX
		rst	#20			;BSDOS

OUTUU		call	OUT
		call	refresh_pane
		jp	main1
NUN		or	a
		jr	z,NU
		xor	a
		ld	(INTERVAL),a
		push	bc
		dec	bc
		ld	h,b
		ld	l,c
		ld	bc,(INTFRST)

		ld	a,dos_unerix		;sluzba UNERIX
		rst	#20			;BSDOS

		pop	bc
		jr	NU
UNTXT		db	"        Undelet"
		db	"ing Files      "
		nop
		db	"         Please"
		db	" Wait          "
		nop
		db	"               "
		db	"               "
		nop
UNJEDEN		ld	bc,(FILE1)
		call	TDEL
		jp	c,main
		call	CHANGE
		ld	bc,(FILE1)

		ld	a,dos_unerax		;sluzba UNERAX
		rst	#20			;BSDOS

		call	refresh_pane
		jp	main1

COPY		call	CHANGE
		ld	hl,(LENDIR1)
		ld	a,h
		or	l
		jp	z,main
		ld	bc,1
FCOP		push	bc
		call	OZNTEST
		pop	bc
		jr	nz,COPVIC
		inc	bc
		ld	hl,(LENDIR1)
		call	cp_hl_bc
		jr	nz,FCOP
		jp	COPJEDEN
COPVIC		call	CHANGE
		ld	hl,10*256+8
		ld	de,7*256+16
		call	IN
		exx
		ld	hl,11*256+17
		ld	de,COTXT
		ld	b,5
		ld	a,31
		call	PMNU
		exx
		ld	a,120
		call	MENU2
		ld	bc,1
NXTCO		push	bc
		call	PROZENT

		ld	ix,FASTMEM		;adresa buffra
		ld	a,dos_getsub		;sluzba GETSUB
		rst	#20			;BSDOS

		jr	z,OUTCO
		pop	bc
		ld	a,(FASTMEM)
		rla
		jr	nc,NCOP
		push	bc
		call	OZNTEST
		pop	bc
		jr	z,NCOP
		push	bc
		call	COPFILE
		pop	bc
NCOP		inc	bc
		ld	hl,(LENDIR1)
		call	cp_hl_bc
		jr	nz,NXTCO
		push	bc
OUTCO		pop	bc
		call	OUT
		jp	panely

COTXT		db	"        Copying"
		db	" Files         "
		nop
		db	"         Please"
		db	" Wait          "
		nop
		db	"               "
		db	"               "
		nop
		db	"               "
		db	"               "
		nop
		db	"               "
		db	"               "
		nop

COPJEDEN	ld	bc,(FILE1)
		call	TDEL
		jp	nc,main
		call	CHANGE
		ld	hl,10*256+8
		ld	de,7*256+16
		call	IN
		exx
		ld	hl,11*256+17
		ld	de,COTXT
		ld	b,5
		ld	a,31
		call	PMNU
		exx
		ld	a,120
		call	MENU2
		ld	bc,(FILE1)
		call	COPFILE
		call	OUT
		jp	panely

;bc=file number
COPFILE		ld	hl,#3E3
		set	7,(hl)
		push	bc
		ld	hl,FASTMEM+6
		ld	de,NAME
		ld	bc,10
		ldir
		ld	de,NAME
		ld	hl,14*256+29
		call	print64
		pop	bc
		call	RESIN
		call	SETDEST
		call	RESOUT
		call	SETSOUR
		ld	a,(FASTMEM)
		bit	5,a
		ret	z
		ld	hl,(FASTMEM+#18)
		ld	de,(FASTMEM+#1A)

		ld	a,dos_howsec		;sluzba HOWSEC
		rst	#20			;BSDOS

		ld	(LENFILE+1),bc
NXBYTE		ld	hl,(#18+FASTMEM)
		ld	de,(#1A+FASTMEM)
		ld	a,h
		or	l
		or	d
		or	e
		jp	z,CLOSE

		ld	a,dos_dec32		;sluzba DEC32
		rst	#20			;BSDOS

		ld	(FASTMEM+#18),hl
		ld	(FASTMEM+#1A),de
		call	READBYTE
		call	WRITBYTE
		jr	NXBYTE

READBYTE	ld	hl,0
		ld	a,h
		or	l
		jr	z,SEQREAD
SEQREAD1		ld	de,SECTIN
		add	hl,de
		ld	a,(hl)
		ld	(PREDEJ),a
		ld	de,1024
		ld	hl,(READBYTE+1)
		inc	hl
		call	cp_hl_de
		jr	z,SEQINSET
SEQIN1		ld	(READBYTE+1),hl
		ret
SEQINSET	ld	hl,0
		jr	SEQIN1

SEQREAD		call	SETSOUR
SEQIN		ld	bc,-1
		inc	bc
		ld	(SEQIN+1),bc
		call	PROFILE

		ld	bc,(SEQIN+1)		;do BC celkovy pocet sektorov
		ld	ix,SECTIN		;buffer na data
FILENUM		ld	hl,0			;cislo suboru s ktorym ideme narabat
		ld	e,1			;nahravat budeme po jednom sektore
		ld	a,dos_loa1x		;sluzba LOA1X
		rst	#20			;BSDOS

		ld	e,#ff			;nevypinaj motor ani ked nie je mechanika aktivna
		ld	a,fdc_setoff		;sluzba SETOFF
		rst	#18			;FDC BIOS
		
		ld	hl,#3E3
		set	7,(hl)
		ld	hl,(READBYTE+1)
		jr	SEQREAD1

WRITBYTE	ld	hl,0
		ld	de,SECTOUT
		add	hl,de
		ld	a,(PREDEJ)
		ld	(hl),a
		ld	de,1024
		ld	hl,(WRITBYTE+1)
		inc	hl
		call	cp_hl_de
		jr	z,SEQOUTST
		ld	(WRITBYTE+1),hl
		ret
SEQOUTST	call	SETDEST
SEQOUT		ld	bc,-1
		inc	bc
		ld	(SEQOUT+1),bc
		ld	ix,SECTOUT
DESTNUM		ld	hl,0
		ld	a,#25
		ld	e,1
		rst	#20			;BSDOS

		ld	e,#ff			;nevypinaj motor ani ked nie je mechanika aktivna
		ld	a,fdc_setoff		;sluzba SETOFF
		rst	#18			;FDC BIOS

		ld	hl,#3E3
		set	7,(hl)
RESOUT1		ld	hl,0
		ld	(WRITBYTE+1),hl
		ld	hl,SECTOUT
		ld	de,SECTOUT+1
		ld	bc,1023
		ld	(hl),0
		ldir
		ret
CLOSE		ld	bc,(SEQIN+1)
		inc	bc
		call	PROFILE
		ld	hl,(WRITBYTE+1)
		ld	a,h
		or	l
		jr	z,CLOSE1
		call	SEQOUTST
CLOSE1		call	SETSOUR
		xor	a
		ld	(#03E3),a
		ret

PREDEJ		nop

SETSOUR		ld	a,(active_drive_1)

		ld	e,a			;v E mame cislo mechaniky
		ld	a,dos_setdrv		;sluzba SETDRV
		rst	#20			;BSDOS

		ld	a,(active_dir_1)

		ld	e,a			;v E mame cislo adresara
		ld	a,dos_setdir		;sluzba SETDIR
		rst	#20			;BSDOS

		ld	a,128
		ld	(#03E3),a
		ret
SETDEST		ld	a,(active_drive_2)

		ld	e,a			;v E mame cislo mechaniky
		ld	a,dos_setdrv		;sluzba SETDRV
		rst	#20			;BSDOS

		ld	a,(active_dir_2)
		ld	e,a			;v E mame cislo adresara
		ld	a,dos_setdir		;sluzba SETDIR
		rst	#20			;BSDOS

		ld	a,128
		ld	(#03E3),a
		ret

RESIN		ld	(FILENUM+1),bc

		ld	ix,FASTMEM		;adresa buffra
		ld	a,dos_getsub		;sluzba GETSUB
		rst	#20			;BSDOS

		ld	hl,-1
		ld	(SEQIN+1),hl
		ld	hl,0
		ld	(READBYTE+1),hl
		ret

RESOUT		ld	a,#26
		ld	ix,FASTMEM
		rst	#20			;BSDOS
		jp	nc,DFULL
		ld	(DESTNUM+1),hl
		ld	hl,-1
		ld	(SEQOUT+1),hl
		jp	RESOUT1

DFULL		call	OUT
		jp	panely

RENAME		call	CHANGE
		ld	hl,(LENDIR1)
		ld	a,h
		or	l
		jp	z,main
		ld	bc,1
FREN		push	bc
		call	OZNTEST
		pop	bc
		jr	nz,RENVIC
		inc	bc
		ld	hl,(LENDIR1)
		call	cp_hl_bc
		jr	nz,FREN
		jp	RENJEDEN
RENVIC		call	CHANGE
		ld	bc,1
NXTRN		push	bc
;		call PROZENT

		ld	ix,FASTMEM		;adresa buffra
		ld	a,dos_getsub		;sluzba GETSUB
		rst	#20			;BSDOS

		jr	z,OUTRN
		pop	bc
		ld	a,(FASTMEM)
		rla
		jr	nc,NREN
		push	bc
		call	OZNTEST
		pop	bc
		jr	z,NREN
		push	bc
		call	RENAM
		pop	bc
NREN		inc	bc
		ld	hl,(LENDIR1)
		call	cp_hl_bc
		jr	nz,NXTRN
		push	bc
OUTRN		pop	bc
		jp	panely
RENJEDEN	ld	bc,(FILE1)
		call	TDEL
		jp	nc,main
		call	CHANGE
		ld	bc,(FILE1)
		call	RENAM
		call	OUT
		jp	panely

RENAM		ld	hl,FASTMEM+#06
		ld	de,NAME
		ld	(REX+1),bc
		ld	bc,10
		ldir
		ld	hl,10*256+8
		ld	de,4*256+16
		call	IN
		exx
		ld	hl,11*256+17
		ld	de,RNTXT1
		call	print64
		ld	hl,11*256+35
		ld	de,NAME
		call	print64
		ld	hl,12*256+17
		ld	de,RNTXT2
		call	print64
		exx
		ld	a,120
		call	MENU2
		ld	hl,10*256+26
		ld	de,RNTXT3
		call	print64
		ld	hl,10*256+37
		ld	a,205
		call	char64
		ld	hl,12*256+35
		ld	de,8315
		ld	iyl,11
		call	INTXT
		jr	nc,RNB
		ld	hl,TEXT
		ld	de,FASTMEM+#06
		ld	bc,10
		ldir
REX		ld	hl,0
		ld	ix,FASTMEM
		ld	a,#1B
		rst	#20			;BSDOS
RNB		call	OUT
		ret
RNTXT1		db	" Old name of fi"
		db	"le:"
		nop
RNTXT2		db	" Enter new name"
		db	":             "
		nop
RNTXT3		db	"File Rename"
		nop


VIEW		ld	bc,(FILE1)
		call	TDEL
		jp	nc,main
		call	CHANGE
		call	VPOZADI
		ld	bc,(FILE1)

		ld	ix,FASTMEM		;adresa buffra
		ld	a,dos_getsub		;sluzba GETSUB
		rst	#20			;BSDOS
;getsub
		jp	z,OUTV
		ld	de,(FASTMEM+#1A)
		ld	hl,(FASTMEM+#18)

		ld	a,dos_howsec		;sluzba HOWSEC
		rst	#20			;BSDOS

		ld	(LENSEC),bc

		ld	e,1			;vypis znakov bude prebiehat do pamate, nie na obrazovku
		ld	a,dos_sddx		;sluzba SDDX
		rst	#20			;BSDOS

		ld	hl,(LENSEC)
		ld	iy,VTXT1
		call	dec2char16_j
		ld	hl,(FASTMEM+#16)
		ld	iy,NUMBER
		call	dec2char16_j
		ld	hl,14
		ld	de,NUMBER
		call	print64

		ld	e,1			;vypis znakov bude prebiehat do pamate, nie na obrazovku
		ld	a,dos_sddx		;sluzba SDDX
		rst	#20			;BSDOS

		ld	de,(FASTMEM+#1A)
		ld	hl,(FASTMEM+#18)
		ld	iy,NUMBER32
		call	dec2char32_j
		ld	hl,20
		ld	de,NUMBER32
		call	print64
		xor	a
		ld	(FASTMEM+16),a
		ld	hl,3
		ld	de,FASTMEM+6
		call	print64
		ld	a,(FASTMEM+5)
		add	a,48
		ld	(ZNK),a
		ld	hl,1
		call	PRD
		ld	bc,0
		ld	(POCSEC),bc
VIEW1		ld	hl,BOOT
		ld	de,BOOT+1
		ld	bc,1023
		ld	(hl),0
		ldir

		ld	hl,(FILE1)		;do HL dame cislo suboru
		ld	ix,BOOT			;adresa bufferu pre data
		ld	bc,(POCSEC)		;celkovy pocet sektorov
		ld	e,1			;nahravame po jednom sektore
		ld	a,dos_loa1x		;sluzba LOA1X
		rst	#20			;BSDOS

		ld	e,1			;vypis znakov bude prebiehat do pamate, nie na obrazovku
		ld	a,dos_sddx		;sluzba SDDX
		rst	#20			;BSDOS

		ld	hl,(POCSEC)
		inc	hl
		ld	iy,VTXT2
		call	dec2char16_j
		ld	hl,256*23+1
		ld	de,VTXT
		call	print64
		call	VIEWP
VIEW0		call	ESCAPE
		jr	nc,OUTV
		call	inkey
		cp	11
		jr	z,VUP
		cp	10
		jr	z,VDO
		cp	8
		jr	z,VSEC0
		cp	9
		jr	z,VSECL
		jr	VIEW0
OUTV		ld	sp,(panely+1)
		jp	panely1

VDO		ld	bc,(POCSEC)
		ld	hl,(LENSEC)
		dec	hl
		call	cp_hl_bc
		jr	z,VIEW0
		inc	bc
		jr	VVV
VUP		ld	bc,(POCSEC)
		ld	a,b
		or	c
		jr	z,VIEW0
		dec	bc
VVV		ld	(POCSEC),bc
		jp	VIEW1
VSEC0		ld	bc,(POCSEC)
		ld	a,b
		or	c
		jr	z,VIEW0
		ld	bc,0
		jr	VVV
VSECL		ld	bc,(POCSEC)
		ld	hl,(LENSEC)
		dec	hl
		call	cp_hl_bc
		jr	z,VIEW0
		ld	bc,(LENSEC)
		dec	bc
		jr	VVV

VPOZADI		ld	hl,16384
		ld	de,16385
		ld	bc,6143
		ld	(hl),0
		ldir
		ld	hl,22528+32
		ld	de,22528+33
		ld	bc,767-64
		ld	(hl),%1101000
		ldir
		ld	hl,22528+32
		ld	de,22528+33
		ld	bc,32
		ld	(hl),7
		ldir
		ld	bc,63
		ld	(hl),%1001111
		ldir
		ld	hl,23296-128
		ld	de,23296-127
		ld	bc,64
		ld	(hl),%1001111
		ldir
		ld	bc,31
		ld	(hl),7
		ldir
		ret
VIEWP		ld	hl,BOOT
		ld	(PVV),hl
		ld	bc,1024
		ld	hl,256*4+0
NVV		ld	(SVV),hl
		ld	hl,(PVV)
		ld	a,(hl)
		cp	32
		jr	nc,NV
		ld	a,'.'
NV		inc	hl
		ld	(PVV),hl
		ld	hl,(SVV)
		ld	(SV),bc
		call	char64
		ld	bc,(SV)
		dec	bc
		ld	a,b
		or	c
		ret	z
		inc	l
		ld	a,l
		cp	64
		jr	c,NVV
		ld	l,0
		inc	h
		jr	NVV
PVV		dw	0
SVV		dw	0
SV		dw	0

VTXT		db	"Sector:"
VTXT2		db	"      of "
VTXT1		db	"     "
		nop
LENSEC		dw	0
POCSEC		dw	0
PRD		ld	de,ZNK
		jp	print64
ZNK		nop
		nop

PROZENT		push	hl
		push	de
		push	bc

		ld	e,1			;vypis znakov bude prebiehat do pamate, nie na obrazovku
		ld	a,dos_sddx		;sluzba SDDX
		rst	#20			;BSDOS

		ld	hl,(LENDIR1)
		pop	bc
		push	bc
		call	PROCALC
		ld	l,24
		ld	h,13
		ld	de,PROZ
		call	print64
		pop	bc
		pop	de
		pop	hl
		ret

PROFILE		push	hl
		push	de
		push	bc

		ld	e,1			;vypis znakov bude prebiehat do pamate, nie na obrazovku
		ld	a,dos_sddx		;sluzba SDDX
		rst	#20			;BSDOS
		
LENFILE		ld	hl,0
		pop	bc
		push	bc
		call	PROCALC
		ld	l,24
		ld	h,15
		ld	de,PROZ
		call	print64
		pop	bc
		pop	de
		pop	hl
		ret

PROCALC		ld	a,h
		or	a
		jr	nz,VELFILE
		ld	a,16
		cp	l
		jr	c,VELFILE
		push	bc
		ld	d,h
		ld	e,l
		ld	hl,16
		call	LOM
		ld	a,l
		or	a
		jr	nz,MALNUL
		ld	a,1
MALNUL		pop	bc
		ld	b,a
		xor	a
MALNUL1		add	a,c
		djnz	MALNUL1
		ld	b,a
		jr	PROW
VELFILE		srl	h
		rr	l
		srl	h
		rr	l
		srl	h
		rr	l
		srl	h
		rr	l
		ld	d,h
		ld	e,l
		ld	h,b
		ld	l,c
		call	LOM
		ld	b,l
		ld	a,16
		cp	b
		jr	nc,PROW
		ld	b,16
PROW		ld	hl,PROZ
		inc	b
		ld	c,17
PROX		ld	(hl),176
		inc	hl
		dec	c
		ld	a,c
		or	a
		jr	nz,PROX
		ld	hl,PROZ
PROY		ld	(hl),219
		inc	hl
		djnz	PROY
		ret

REDISK		call	CHANGE

REDISKY		ld	a,dos_getcst		;sluzba GETCST
		rst	#20			;BSDOS

		call	activate_drive
		or	a
		jp	z,RDB
		cp	1
		jr	z,REDISKY
		ld	de,1
		ld	hl,BOOT
		call	read_sector
		or	a
		jp	z,RDB
		cp	1
		jr	z,REDISKY

		ld	a,fdc_pasive		;sluzba PASIVE
		rst	#18			;FDC BIOS

		ld	hl,BOOT+#26
		ld	de,NAME
		ld	bc,10
		ldir
		ld	hl,10*256+8
		ld	de,4*256+16
		call	IN
		exx
		ld	hl,11*256+17
		ld	de,RDTXT1
		call	print64
		ld	hl,11*256+35
		ld	de,NAME
		call	print64
		ld	hl,12*256+17
		ld	de,RDTXT2
		call	print64
		exx
		ld	a,120
		call	MENU2
		ld	hl,10*256+26
		ld	de,RDTXT3
		call	print64
		ld	hl,10*256+37
		ld	a,205
		call	char64
		ld	hl,12*256+35
		ld	de,8315
		ld	iyl,11
		call	INTXT
		jr	nc,RDB
		ld	hl,TEXT
		ld	de,BOOT+#26
		ld	bc,10
		ldir
REDISKX		ld	a,dos_getcst		;sluzba GETCST
		rst	#20			;BSDOS

		call	activate_drive
		or	a
		jr	z,RDB
		cp	1
		jr	z,REDISKX
		ld	de,1
		ld	hl,BOOT
		call	write_sector
		or	a
		jr	z,RDB
		cp	1
		jr	z,REDISKX

		ld	a,fdc_pasive		;sluzba PASIVE
		rst	#18			;FDC BIOS

RDB		call	OUT
		jp	main
RDTXT1		db	" Old name of di"
		db	"sk:"
		nop
RDTXT2		db	" Enter new name"
		db	":             "
		nop
RDTXT3		db	"Rename Disk"
		nop

SETTIME		ld	hl,10*256+7
		ld	de,3*256+18
		call	IN
		exx
		ld	hl,11*256+15
		ld	de,STTXT2
		call	print64
		exx
		ld	a,120
		call	MENU2
		ld	hl,10*256+28
		ld	de,STTXT1
		call	print64
		ld	hl,11*256+41
		ld	de,12346
		ld	iyl,7
		call	INTXT
		jr	nc,BP
		ld	hl,TEXT
		ld	ix,RNG
		ld	b,6
RERNG		ld	a,(hl)
		cp	(ix+0)
		jr	nc,ITIME
		sub	48
		ld	(hl),a
		inc	l
		inc	ix
		djnz	RERNG
		ld	bc,15*256+3
		ld	a,7
		out	(c),a
		ld	hl,TEXT
		ld	b,6
		otir
		ld	b,15
		ld	a,4
		out	(c),a
		ld	b,13
		db	#ED,#71
;out (c),0
BP		call	OUT
		jp	main
ITIME		call	OUT
		
		ld	hl,txt_bad_string	;adresa textu
		ld	a,dos_messx		;sluzba MESSX
		rst	#20			;BSDOS
		
		call	wait_5_ints
		jp	c,SETTIME
		jp	main

RNG:		db	51,58,54,58,54,58
STTXT1:		db	"Set Time"
		nop
STTXT2:		db	" Enter new time"
		db	" (hhmmss):     "
		db	"    "
		nop
txt_bad_string:	db	"Bad string. Again ?"
		db	#00,#C9


;Podprogram pre obsluhu klavesnice
;klasicky INKEY$ zavisly od ZX ROM!
;output: a=stlacena klavesa
inkey:		call	rom_wr_protect		;odstrankujeme do ROM
		ld	iy,39
		call	654			;#028e
		ret	nz
		call	798			;#031e
		ret	nc
		dec	d
		ld	e,a
		call	819			;#0333
		jp	dos_wr_enabled		;navrat s prestrankovanim do DOSu

AKEY		call	inkey
		cp	13
		ret	z
		call	ESCAPE
		ret	nc
		jr	AKEY
ESCAPE		ld	a,247
		in	a,(254)
		rra
		ret	c
		ld	a,254
		in	a,(254)
		rra
		ret

;Pocka 5 preruseni
wait_5_ints:	ld	b,5
		ei
w5i:		halt
		djnz	w5i
		ret

;Nahrada cp hl,de
cp_hl_de:	or	a
		sbc	hl,de
		add	hl,de
		ret

;Nahrada cp hl,bc
cp_hl_bc:	or	a
		sbc	hl,bc
		add	hl,bc
		ret

MOD		ld	a,h
		ld	c,l
		ld	hl,0
		ld	b,16
MOD2		sll	c
		rla
		adc	hl,hl
		sbc	hl,de
		jr	nc,MOD1
		add	hl,de
		dec	c
MOD1		djnz	MOD2
		ret

LOM		call	MOD
		ld	h,a
		ld	l,c
		ret

KRAT		ld	b,16
		ld	a,h
		ld	c,l
		ld	hl,0
KRAT2		add	hl,hl
		rl	c
		rla
		jr	nc,KRAT1
		add	hl,de
KRAT1		djnz	KRAT2
		ret
NAS		ld	hl,0
NAS0		add	hl,de
		djnz	NAS0
		ret

;BSDOS #DEC8X, nezarovnane
dec2char8:	ld	ix,NUM			;nastavenie pozicie vypisu
		ld	(XXX),ix		;cez systemovu premennu XXX
		ld	c,0			;vypisovat budeme iba platne znaky
		ld	a,dos_dec8x		;sluzba DEC8X
		rst	#20			;BSDOS

		xor	a
		ld	(NUM+3),a
		ret

;BSDOS #DEC16X, nezarovnane
dec2char16:	ld	ix,NUM			;nastavenie pozicie vypisu
		ld	(XXX),ix		;cez systemovu premennu XXX
		ld	c,0			;vypisovat budeme iba platne znaky
		ld	a,dos_dec16x		;sluzba DEC16X
		rst	#20			;BSDOS

		xor	a
		ld	(NUM+5),a
		ret

;BSDOS #DEC32X, nezarovnane
dec2char32:	ld	ix,NUM			;nastavenie pozicie vypisu
		ld	(XXX),ix		;cez systemovu premennu XXX
		ld	c,0			;vypisovat budeme iba platne znaky
		ld	b,5			;vypiseme maximalne 5 znakov
		ld	a,dos_dec32x		;sluzba DEC32X
		rst	#20			;BSDOS

		xor	a
		ld	(NUM+5),a
		ret

;BSDOS #DEC8X, zarovnane v pravo
;input: iy=pozicia textu
dec2char8_j:	ld	c,' '			;medzera namiesto nevyznamnych uvodnych nul
		ld	(XXX),iy		;pozicia textu do systemovej premennej XXX
		ld	a,dos_dec8x		;sluzba DEC8X - Vypisuje osembitove desiatkove cislo
		rst	#20			;BSDOS
		ret

;BSDOS #DEC16X, zarovnane v pravo
;input: iy=pozicia textu
dec2char16_j:	ld	c,' '			;medzera namiesto nevyznamnych uvodnych nul			
		ld	(XXX),iy		;pozicia textu do systemovej premennej XXX
		ld	a,dos_dec16x		;sluzba DEC16X - vypisuje 16-bitove desiatkove cislo
		rst	#20			;BSDOS
		ret

;BSDOS #DEC32X, zarovnane v pravo
;input: iy=pozicia textu
dec2char32_j:	ld	c,' '			;medzera namiesto nevyznamnych uvodnych nul
		ld	(XXX),iy		;pozicia textu do systemovej premennej XXX
		ld	b,7			;vypiseme maximalne 7 znakov
		ld	a,dos_dec32x		;sluzba DEC32X - vypisuje 32-bitove desiatkove cislo
		rst	#20			;BSDOS
		ret

;ix=cislo
;nc=overflow
A2N		ld	hl,TEXT
		ld	bc,6
		ld	a,32
		ld	e,255
A2N0		inc	e
		cpi
		jr	nz,A2N0
		ld	c,e
		ld	ix,0
		dec	hl
		dec	hl
		ld	de,1
XCV0		ex	af,af'
		ld	a,(hl)
		sub	48
		or	a
		jr	z,XCV2
		ld	b,a
		ex	af,af'
XCV1		add	ix,de
		jp	c,NOVAL
		djnz	XCV1
XCV2		push	bc
		ex	de,hl
		sla	l
		rl	h
		push	hl
		sla	l
		rl	h
		sla	l
		rl	h
		pop	bc
		add	hl,bc
		ex	de,hl
		pop	bc
		dec	hl
		dec	c
		jr	nz,XCV0
		scf
		ret
NOVAL		or	a
		ret

;hl=pozice kurzoru
;d=prvni testovany znak
;e=posledni testovany znak
;de=8315 (all), de=12346 (num)
;iyl=max. pocet znaku+1
;nc=break
INTXT		ld	(POS),hl
		ld	a,d
		ld	(ZNAK1+1),a
		ld	a,e
		ld	(ZNAK2+1),a
		push	hl
		push	de
		push	bc
		push	af
		ld	b,iyl
		ld	hl,TEXT
INTXT0		ld	(hl),32
		inc	l
		djnz	INTXT0
		ld	(hl),b
		pop	af
		pop	bc
		pop	de
		pop	hl
		push	hl
		call	pixel_address
		call	attr_address
		ld	b,iyl
		srl	b
		inc	b
INTXT00		ld	(hl),40
		inc	l
		djnz	INTXT00
		ld	ix,TEXT
		pop	hl
		ld	a,254
		call	char64
INTXT1		call	ESCAPE
		jp	nc,BRK
		push	hl
		push	iy
		call	inkey
		pop	iy
		pop	hl
		cp	39
		jr	z,INTXT1
		cp	12
		jp	z,DEL
		cp	13
		jp	z,ETR
ZNAK1		cp	32
		jr	c,INTXT1
ZNAK2		cp	123
		jr	nc,INTXT1
		ex	af,af'
		ld	a,xh
		ld	yh,a
		ld	a,(iy-2)
		cp	32
		jp	nz,INTXT1
		ld	a,yl
		dec	a
		cp	xl
		jp	z,INTXT1
		push	hl
		push	de
		push	bc
		push	af
		ld	a,yl
		dec	a
		sub	xl
		ld	b,0
		ld	c,a
		ld	d,TEXT/256
		ld	a,yl
		dec	a
		ld	e,a
		ld	h,d
		ld	l,e
		dec	l
		lddr
		ldd
		ex	af,af'
		ld	(ix+0),a
		ld	hl,(POS)
		ld	de,TEXT
		call	REMOV2
		call	print64
		inc	ixl
		pop	af
		pop	bc
		pop	de
		pop	hl

		inc	l
		ld	a,254
		call	char64
		call	wait_5_ints
		jr	INTXT1
DEL		ld	a,xl
		or	a
		jp	z,INTXT1
		push	hl
		push	de
		push	bc
		push	af
		push	ix
		pop	hl
		ld	d,h
		ld	e,l
		dec	e
		ld	a,yl
		sub	xl
		ld	b,0
		ld	c,a
		ldir
		dec	l
		ld	(hl),32
		dec	xl
		ld	hl,(POS)
		ld	de,TEXT
		call	REMOV2
		call	print64
		pop	af
		pop	bc
		pop	de
		pop	hl
		dec	l
		ld	a,254
		call	char64
		call	wait_5_ints
		jp	INTXT1
ETR		scf
		ret
BRK		or	a
		ret
REMOV		push	hl
		call	pixel_address
		ld	a,h
		add	a,7
		ld	h,a
		ld	(hl),0
		pop	hl
		ret
REMOV2		push	hl
		call	pixel_address
		ld	b,8
REMOV20		ld	(hl),0
		inc	h
		djnz	REMOV20
		pop	hl
		ret

;hl=zacatek inv. oblasti
;a=delka inv. oblasti(0-63)
INV		push	hl
		ld	b,a
INV0		push	bc
		call	INV1
		inc	l
		pop	bc
		djnz	INV0
		pop	hl
		ret
INV1		push	hl
		call	pixel_address
		or	a
		jr	nz,SCND
		ld	b,8
I0		ld	a,(hl)
		xor	%00001111
		ld	(hl),a
		inc	h
		djnz	I0
		pop	hl
		ret
SCND		ld	b,8
I1		ld	a,(hl)
		xor	%11110000
		ld	(hl),a
		inc	h
		djnz	I1
		pop	hl
		ret

;hl=umisteni
;de=rozmery
IN		push	hl
		push	de
		ld	a,l
		add	a,a
		ld	l,a
		call	pixel_address
		ld	(OUT+1),hl
		ld	a,d
		ld	(LOP2-1),a
		ld	(LOP4-1),a
		or	a
		rla
		rla
		rla
		ld	(LOP3-1),a
		ld	b,a
		ld	a,e
		ld	(RANG1+1),a
		ld	(RANG2+1),a
		ld	(RANG3+1),a
		ld	(LOP4+1),a
		ld	a,32
		sub	e
		ld	(ADDED1+1),a
		ld	(ADDED2+1),a
		push	hl
		ld	de,STORE
LOP1		push	bc
		push	hl
RANG1		ld	bc,0
		ldir
		pop	hl
		call	DOWNHL
		pop	bc
		djnz	LOP1
		pop	hl
		call	attr_address
		ld	b,0
LOP2		push	bc
RANG2		ld	bc,0
		ldir
ADDED1		ld	bc,0
		add	hl,bc
		pop	bc
		djnz	LOP2
		pop	de
		pop	hl
		ret

OUT		ld	de,0
		ld	hl,STORE
		push	de
		ld	b,0
LOP3		push	bc
		push	de
RANG3		ld	bc,0
		ldir
		pop	de
		ex	de,hl
		call	DOWNHL
		ex	de,hl
		pop	bc
		djnz	LOP3
		pop	de
		ex	de,hl
		call	attr_address
		ex	de,hl
		ld	a,0
LOP4		ld	bc,0
		ldir
ADDED2		ld	bc,0
		ex	de,hl
		add	hl,bc
		ex	de,hl
		dec	a
		jr	nz,LOP4
		ret

DOWNHL		inc	h
		ld	a,h
		and	7
		ret	nz
		ld	a,l
		add	a,32
		ld	l,a
		ret	c
		ld	a,h
		sub	8
		ld	h,a
		ret

;Vypocet adresy atributu pod pixelovou adresou
;input: hl=pixelova adresa
attr_address:	ld	a,h
		rrca
		rrca
		rrca
		xor	80
		ld	h,a
		ret

LINE1		ld	b,a
LINE0		ld	a,196
		push	bc
		call	char64
		pop	bc
		inc	l
		djnz	LINE0
		ret

;hl=umisteni
;de=rozmery
MENU1		push	hl
		push	de
		ld	a,l
		add	a,a
		ld	l,a
		push	hl
		call	pixel_address
		call	attr_address
		ld	b,d
		ld	a,e
		ld	(SIRKA+1),a
LP1		push	bc
		push	hl
SIRKA		ld	b,0
LP2		ld	(hl),48
		inc	l
		djnz	LP2
		pop	hl
		ld	bc,32
		add	hl,bc
		pop	bc
		djnz	LP1
		pop	hl
		push	hl
		ld	a,218
		push	de
		push	de
		call	char64
		pop	de
		inc	l
		ld	a,e
		add	a,a
		sub	2
		call	LINE1
		ld	a,191
		call	char64
		pop	de
		pop	hl
		inc	h
		push	de
		dec	d
		dec	d
		ld	b,d
		ld	a,e
		add	a,a
		dec	a
		ld	(PRICTI+1),a
LPP1		ld	a,242
		push	hl
		push	bc
		call	char64
		ld	a,l
PRICTI		add	a,0
		ld	l,a
		ld	a,179
		call	char64
		pop	bc
		pop	hl
		inc	h
		djnz	LPP1
		ld	a,192
		call	char64
		inc	l
		pop	de
		ld	a,e
		add	a,a
		sub	2
		call	LINE1
		ld	a,217
		call	char64
		pop	de
		pop	hl
		ret
;hl=umisteni
;de=rozmery
;a=atribut
MENU2		ld	(LLP2+1),a
		ld	a,l
		add	a,a
		ld	l,a
		push	hl
		call	pixel_address
		call	attr_address
		ld	b,d
		ld	a,e
		ld	(LSIRKA+1),a
LLP1		push	bc
		push	hl
LSIRKA		ld	b,0
LLP2		ld	(hl),0
		inc	l
		djnz	LLP2
		pop	hl
		ld	bc,32
		add	hl,bc
		pop	bc
		djnz	LLP1
		pop	hl
		push	hl
		ld	a,201
		push	de
		push	de
		call	char64
		pop	de
		inc	l
		ld	a,e
		add	a,a
		sub	2
		call	LINE2
		ld	a,187
		call	char64
		pop	de
		pop	hl
		inc	h
		push	de
		dec	d
		dec	d
		ld	b,d
		ld	a,e
		add	a,a
		dec	a
		ld	(LPRICTI+1),a
LLPP1		ld	a,247
		push	hl
		push	bc
		call	char64
		ld	a,l
LPRICTI		add	a,0
		ld	l,a
		ld	a,186
		call	char64
		pop	bc
		pop	hl
		inc	h
		djnz	LLPP1
		ld	a,200
		call	char64
		inc	l
		pop	de
		ld	a,e
		add	a,a
		sub	2
		call	LINE2
		ld	a,188
		call	char64
		ret
LINE2		ld	b,a
LINE00		ld	a,205
		push	bc
		call	char64
		pop	bc
		inc	l
		djnz	LINE00
		ret

;Tlac textu, 64 znakov na riadok
;input:	hl=pozicia (h=riadok, l=stlpec)
;	de=adresa textu
print64:	ld	a,(de)
		or	a
		ret	z
		call	char64
		inc	de
		inc	l
		ld	a,l
		cp	64
		jr	c,print64
		ld	l,0
		inc	h
		jr	print64

;Tlac znaku, 64 znakov na riadok
;input:	hl=pozicia (h=riadok, l=stlpec)
;	a=kod znaku
char64:		push	bc
		push	de
		push	hl
		push	af
		call	pixel_address
		or	a
		jr	z,char64_2
		ld	c,#F0
		jr	char64_1

char64_2:	ld	c,#0F
char64_1:	pop	af
		ex	de,hl
		ld	l,a
		ld	h,0
		add	hl,hl
		add	hl,hl
		add	hl,hl
		push	bc
		ld	bc,font64-256
		add	hl,bc
		pop	bc
		ex	de,hl

		ld	b,(hl)
		ld	a,c
		cpl
		and	b
		ld	(hl),a
		ld	a,(de)
		and	c
		or	(hl)
		ld	(hl),a

		inc	de
		inc	h

		ld	b,(hl)
		ld	a,c
		cpl
		and	b
		ld	(hl),a
		ld	a,(de)
		and	c
		or	(hl)
		ld	(hl),a

		inc	de
		inc	h

		ld	b,(hl)
		ld	a,c
		cpl
		and	b
		ld	(hl),a
		ld	a,(de)
		and	c
		or	(hl)
		ld	(hl),a

		inc	de
		inc	h

		ld	b,(hl)
		ld	a,c
		cpl
		and	b
		ld	(hl),a
		ld	a,(de)
		and	c
		or	(hl)
		ld	(hl),a

		inc	de
		inc	h

		ld	b,(hl)
		ld	a,c
		cpl
		and	b
		ld	(hl),a
		ld	a,(de)
		and	c
		or	(hl)
		ld	(hl),a

		inc	de
		inc	h

		ld	b,(hl)
		ld	a,c
		cpl
		and	b
		ld	(hl),a
		ld	a,(de)
		and	c
		or	(hl)
		ld	(hl),a

		inc	de
		inc	h

		ld	b,(hl)
		ld	a,c
		cpl
		and	b
		ld	(hl),a
		ld	a,(de)
		and	c
		or	(hl)
		ld	(hl),a

		inc	de
		inc	h

		ld	b,(hl)
		ld	a,c
		cpl
		and	b
		ld	(hl),a
		ld	a,(de)
		and	c
		or	(hl)
		ld	(hl),a

		pop	hl
		pop	de
		pop	bc
		ret

;Vypocet pixelovej adresy zo suradnic vypisu
;input: hl=pozicia (h=riadky 0-23, l=stlpce 0-63)
pixel_address:	ld	a,h
		push	hl
		and	%00011000
		or	%01000000
		ld	l,0
		rr	h
		rr	l
		rr	h
		rr	l
		rr	h
		rr	l
		ld	h,a
		pop	bc
		bit	0,c
		jr	nz,MODIFY
		ld	a,1
pa_cont:	srl	c
		ld	b,0
		add	hl,bc
		ret
MODIFY:		xor	a
		jr	pa_cont

;Aktivacia mechaniky, testuje aj ci sa zmenila disketa
;input: e=cislo mechaniky
;output:
;a=0 abort
;a=1 opakuj aktivaciu
;a=2 disk je aktivny, disketa nebola vymenena
;a=3 disk je aktivny, disketa bola vymenena
activate_drive:	di
		ld	a,fdc_aktive		;sluzba AKTIVE
		rst	#18			;FDC BIOS
		ei

		cp	1			;obsluha stavu disk not ready
		ret	nz			;navrat ak sa aktivacia podarila
		ld	(BIOS),a		;ulozi sa status
		
		ld	hl,msg_dsk_nr		;adresa textu Disk not ready
		ld	a,dos_messx		;sluzba MESSX
		rst	#20			;BSDOS

		jr	c,adrverr		;ak bol abort
		xor	a			;nastavi status na abort
		ret				;a navrat

adrverr:	ld	a,1			;inak nastavi status na - chyba, opakuj aktivaciu
		ret				;a navrat


;Nacitanie sektoru, chyby su osetrene
;input: hl=adresa
;d=cislo stopy, e=strana a sektor
;a=0 abort
;a=1 chyba, opakuj nacitanie
;a=2 ok
read_sector:	di
		ld	a,fdc_rdsec		;sluzba RDSEC
		rst	#18			;FDC BIOS
		ei
		rra
		ld	hl,msg_time_out		;time out
		jr	c,rw_err_msg
		rra
		ld	hl,msg_dsk_nr		;disk not ready
		jr	c,rw_err_msg
		rra
		ld	hl,msg_data_lost	;data lost
		jr	c,rw_err_msg
		rra
		ld	hl,msg_crc_err		;crc error
		jr	c,rw_err_msg
		rra
		ld	hl,msg_rec_nf		;record not found
		jr	c,rw_err_msg
		rra
		ld	hl,msg_break		;break
		jr	c,rw_err_msg
		bit	7,a
		ld	hl,msg_rd_err		;ready error
		jr	nz,rw_err_msg

		ld	a,fdc_pasive		;sluzba PASIVE, deaktivuje mechaniku
		rst	#18			;FDC BIOS

		ld	a,2			;ak nebola ziadna chyba, navrat so statusom OK
		ret

;Zapis sektora, chyby su osetrene
;input: hl=adresa
;d=cislo stopy, e=strana a sektor
;a=0 abort
;a=1 chyba, opakuj zapis
;a=2 ok
write_sector:	ld	a,fdc_wrsec		;sluzba WRSEC
		rst	#18			;FDC BIOS

		rra
		ld	hl,msg_time_out		;time out
		jr	c,rw_err_msg
		rra
		ld	hl,msg_dsk_nr		;disk not ready
		jr	c,rw_err_msg
		rra
		ld	hl,msg_data_lost	;data lost
		jr	c,rw_err_msg
		rra
		rra
		ld	hl,msg_rec_nf		;record not founf
		jr	c,rw_err_msg
		rra
		ld	hl,msg_break		;break
		jr	c,rw_err_msg
		rra
		ld	hl,msg_wp		;write protect
		jr	c,rw_err_msg
		rra
		ld	hl,msg_rd_err		;ready error
		jr	c,rw_err_msg

		ld	a,fdc_pasive		;sluzba PASIVE
		rst	#18			;FDC BIOS

		ld	a,2			;ak nebola ziadna chyba, navrat so statusom OK
		ret

;Vypis chyboveho hlasenia
;input: hl=adresa chyboveho hlasenia
;output:
;a=0 abort
;a=1 chyba, opakuj ukon
rw_err_msg:	push	hl

		ld	a,fdc_pasive		;sluzba PASIVE
		rst	#18			;FDC BIOS

		pop	hl
		ld	a,1			;ulozi status
		ld	(BIOS),a

		ld	a,dos_messx		;sluzba MESSX, v HL mame adresu chyboveho hlasenia
		rst	#20			;BSDOS

		jr	c,rwserrend		;ak bol abort
		xor	a			;nastavi status na abort
		ret				;a navrat

rwserrend:	ld	a,1			;nastavi status - chyba, opakuj ukon
		ret				;a navrat

msg_time_out:	db	"Time out"
		db	#00,#C9
msg_dsk_nr:	db	"Disk not ready"
		db	#00,#C9
msg_data_lost:	db	"Data lost"
		db	#00,#C9
msg_crc_err:	db	"CRC error"
		db	#00,#C9
msg_rec_nf:	db	"Record not found"
		db	#00,#C9
msg_break:	db	"Break"
		db	#00,#C9
msg_wp:		db	"Write protect"
		db	#00,#C9
msg_rd_err:	db	"Ready error"
		db	#00,#C9

MSG		ld	(MSGSP1),sp
		ld	sp,MSGSP2+80
		call	TO
		call	wait_5_ints
		ld	hl,(MSGB)
		ld	bc,28
		xor	a
		cpir
		srl	c
		ld	a,20
		add	a,c
		ld	l,a
		ld	de,(MSGB)
		ld	h,11
		call	print64
		ld	de,MSGT1
		ld	hl,12*256+24
		call	print64
		ld	hl,(MSGB)
		ld	de,67
		add	hl,de
		ld	a,(hl)
		cp	77
		jr	z,CO
BIOE		ld	hl,10*256+35
		push	hl
		ld	de,ERROR
		ld	hl,10*256+30
		ld	a,16
DALE		exx
		ld	hl,10*256+9
		ld	de,4*256+15
		call	MENU2
		exx
		call	print64
		pop	hl
		ld	a,205
		call	char64
		ld	hl,12*256+23
		call	YC
		push	af
		call	FROM
		xor	a
		ld	(BIOS),a
		pop	af
		ld	sp,(MSGSP1)
		ret

CO		ld	a,(BIOS)
		or	a
		jr	nz,BIOE
		ld	hl,10*256+37
		push	hl
		ld	de,CONFIRM
		ld	hl,10*256+30
		ld	a,56
		jr	DALE

MSGT1		db	"OK/Rtr      Can"
		db	"cel"
		nop
CONFIRM		db	"Confirm"
		nop
ERROR		db	"Error"
		nop

TO		ld	hl,18505
		ld	de,MSGST
		ld	a,32
TO0		push	hl
		ld	bc,15
TO1		ldi
		dec	hl
		ld	(hl),b
		inc	hl
		jp	pe,TO1
		pop	hl
		ex	af,af'
		call	DOWNHL
		ex	af,af'
		dec	a
		jr	nz,TO0
		ld	hl,22857
		ld	de,MSGST+480
		ld	c,4
TO2		ld	b,15
TO3		ld	a,(hl)
		ld	(de),a
		inc	de
		inc	l
		djnz	TO3
		push	de
		ld	de,17
		add	hl,de
		pop	de
		dec	c
		jr	nz,TO2
		ret

FROM		ld	hl,MSGST
		ld	de,18505
		ld	b,32
FROM0		push	bc
		push	de
		ld	bc,15
		ldir
		pop	de
		ex	de,hl
		call	DOWNHL
		ex	de,hl
		pop	bc
		djnz	FROM0
		ld	hl,22857
		ld	de,MSGST+480
		ld	c,4
FROM1		ld	b,15
FROM2		ld	a,(de)
		ld	(hl),a
		inc	de
		inc	l
		djnz	FROM2
		push	de
		ld	de,17
		add	hl,de
		pop	de
		dec	c
		jr	nz,FROM1
		ret

;hl=pozice
;c=Ok/Rtr
;nc=Cancel/Break
YC		ld	a,8
		call	INV
		ld	a,l
		ld	(LR+2),a
		ld	(LRP+1),a
		add	a,12
		ld	(LRQ+1),a
YC1		push	hl
		call	inkey
		pop	hl
		cp	8
		call	z,LR
		cp	9
		call	z,LR
		cp	13
		jr	z,QD
		call	ESCAPE
		jr	nc,BCK
		jr	YC1

LR		ld	a,l
		cp	0
		jr	z,INC
		ld	a,8
		call	INV
LRP		ld	l,0
		ld	a,8
		call	INV
		call	wait_5_ints
		ret
INC		ld	a,8
		call	INV
LRQ		ld	l,0
		ld	a,8
		call	INV
		call	wait_5_ints
		ret
QD		ld	a,(LR+2)
		cp	l
		jr	nz,BCK
		scf
		ret
BCK		or	a
		ret

status:		ld	hl,MSG			;vypis chybovych hlaseni obsluzi FC
		ld	a,dos_sdmsx		;sluzba SDMSX
		rst	#20			;BSDOS

		xor	a			;sluzba #00 GETVER
		rst	#20			;BSDOS

		ld	(VER),bc
		ld	bc,#80
		add	ix,bc
		ld	(MSGB),ix
		ld	ix,DRV4
		ld	b,4
TDRV		ld	e,b
		push	bc

		ld	a,fdc_info		;sluzba INFO
		rst	#18			;FDC BIOS

		pop	bc
		ld	(ix+0),e
		ld	(ix+1),d
		dec	ix
		dec	ix
		djnz	TDRV
		ld	a,(25)
		ld	(DRV9),a

		ld	a,dos_getcst		;sluzba GETCST
		rst	#20			;BSDOS

		jp	nc,RETDOS
		ld	a,e
		ld	(active_drive_1),a
		ld	(active_drive_2),a
		ld	a,d
		ld	(active_dir_1),a
		ld	(active_dir_2),a
		ld	bc,32765
		ld	a,16
		out	(c),a
		ld	a,(65535)
		ld	d,a
		ld	a,23
		out	(c),a
		ld	a,(65535)
		ld	e,a
		ld	a,d
		cpl
		ld	(65535),a
		ld	a,16
		out	(c),a
		ld	a,(65535)
		cp	d
		jr	nz,NE128
		ld	a,128
NE_128		ld	(MEM128),a
		ld	a,23
		out	(c),a
		ld	a,e
		ld	(65535),a
		ld	a,16
		out	(c),a
		ld	a,d
		ld	(65535),a
		ret
NE128		xor	a
		jr	NE_128

;obsluha prerusenia, zobrazenie hodin
interrupt:	di
		push	af
		push	bc
		push	de
		push	hl
		call	clock
		pop	hl
		pop	de
		pop	bc
		pop	af
		ei
		ret

;hodiny sa vykresluju len ak su povolene v options, inak sa kreslia len medzery
clock:		ld	a,(OPT)
		bit	1,a
		jr	z,SPACES
		ld	hl,LTIME
		ld	bc,256*5+3
		in	a,(c)
		and	15
		add	a,48
		ld	(hl),a
		dec	b
		inc	hl
		in	a,(c)
		and	15
		add	a,48
		ld	(hl),a
		dec	b
		inc	hl
		inc	hl
		in	a,(c)
		and	15
		add	a,48
		ld	(hl),a
		dec	b
		inc	hl
		in	a,(c)
		and	15
		add	a,48
		ld	(hl),a
		dec	b
		inc	hl
		inc	hl
		in	a,(c)
		and	15
		add	a,48
		ld	(hl),a
		dec	b
		inc	hl
		in	a,(c)
		and	15
		add	a,48
		ld	(hl),a
		ld	hl,0*256+54
		ld	de,LTIME
		jp	print64
LTIME		db	0,0,58,0,0,58,0,0
		nop
SPACES		ld	hl,16667
		xor	a
		ld	c,6
SPCS1		push	hl
		ld	b,4
SPCS0		ld	(hl),a
		inc	l
		djnz	SPCS0
		pop	hl
		inc	h
		dec	c
		jr	nz,SPCS1
		ret

WORKB		ld	hl,16384
		ld	de,16385
		ld	bc,6144
		ld	(hl),0
		ldir
		ld	hl,22528
		ld	b,32
EEE		ld	(hl),104
		inc	l
		djnz	EEE
		ld	hl,23264
		ld	b,32
FFF		ld	(hl),104
		inc	l
		djnz	FFF
		ld	de,WORKB1
		ld	hl,0*256+0
		call	print64
		ld	de,WORKB2
		ld	hl,23*256+0
		call	print64
		ld	hl,19*256+4
		ld	de,WORKB3
		ld	a,24
		ld	b,3
		call	PMNU
		ld	hl,19*256+36
		ld	de,WORKB3
		ld	a,24
		ld	b,3
		call	PMNU
		ld	hl,1*256+0
		ld	de,22*256+16
		ld	a,77
		call	MENU2
		ld	hl,1*256+16
		ld	de,22*256+16
		ld	a,77
		call	MENU2
		ld	hl,18*256+2
		ld	a,28
		call	LINE1
		ld	hl,18*256+34
		ld	a,28
		jp	LINE1

WORKB1		db	"  X  File  Util"
		db	"ities  Panel  M"
		db	"anager"
		nop
WORKB2		db	" 1 Lft 2 Rgt 3 "
		db	"View 4 Edit 5 C"
		db	"op 6 Mov 7 Fnd "
		db	"8 Del 9 Nam 0 M"
		db	"enu"
		nop
WORKB3		db	"Path: 000 / 000"
		db	" / 00000"
		nop
WORKB4		db	"Disk name:     "
		db	"        "
		nop
WORKB5		db	"  Free: 00000 s"
		db	"ectors  "
		nop

RETDOS:		di
		ld	sp,0

		ld	hl,0			;vypis chybovych hlaseni bude prebiehat defaultne
		ld	a,dos_sdmsx		;sluzba SDMSX
		rst	#20			;BSDOS

		ld	e,0			;vypis znakov bude prebiehat na obrazovku
		ld	a,dos_sddx		;sluzba SDDX
		rst	#20			;BSDOS

		call	rom_wr_protect

		im	1			;prerusenie na im1
		ld	hl,23295		;zmazanie obrazovky
		ld	de,23294
		ld	bc,6911
		ld	(hl),0
		lddr
		xor	a
		ld	de,65535
		jp	#11CB			;skok na START_NEW v ROM

PROZ		ds	17
		nop
NAME		ds	10
		nop
NUMBER		ds	5
		nop
NUMBE		db	32
		ds	3
		nop
NUMBER32	ds	7
		nop

FILE1		dw	0
POZICE1		dw	2*256+2
INPANEL1	dw	PANEL1
OORT1		dw	PANEL1
OORT2		dw	PANEL1+512
LENDIR1		dw	0
active_drive_1:	nop
active_dir_1:	nop
PANEL1		ds	1024
JIST1		ds	1024
FILE2		dw	0
POZICE2		dw	2*256+34
INPANEL2	dw	PANEL1
OORT3		dw	PANEL1
OORT4		dw	PANEL1+512
LENDIR2		dw	0
active_drive_2:	nop
active_dir_2:	nop
PANEL2		ds	1024
JIST2		ds	1024


font64:		db	#00, #00, #00, #00, #00, #00, #00, #00
		db	#00, #44, #44, #44, #44, #00, #44, #00
		db	#00, #AA, #AA, #00, #00, #00, #00, #00
		db	#00, #00, #AA, #EE, #AA, #EE, #AA, #00
		db	#00, #00, #EE, #CC, #EE, #66, #EE, #00
		db	#00, #AA, #22, #44, #44, #88, #AA, #00
		db	#00, #44, #AA, #44, #AA, #EE, #66, #00
		db	#00, #44, #44, #88, #00, #00, #00, #00
		db	#00, #66, #44, #44, #44, #44, #66, #00
		db	#00, #CC, #44, #44, #44, #44, #CC, #00
		db	#00, #00, #44, #EE, #44, #EE, #44, #00
		db	#00, #00, #44, #44, #EE, #44, #44, #00
		db	#00, #00, #00, #00, #44, #44, #88, #00
		db	#00, #00, #00, #00, #EE, #00, #00, #00
		db	#00, #00, #00, #00, #00, #CC, #CC, #00
		db	#00, #22, #22, #44, #44, #88, #88, #00
		db	#00, #EE, #AA, #AA, #AA, #AA, #EE, #00
		db	#00, #44, #CC, #44, #44, #44, #EE, #00
		db	#00, #EE, #22, #EE, #88, #AA, #EE, #00
		db	#00, #EE, #22, #66, #22, #AA, #EE, #00
		db	#00, #88, #AA, #AA, #EE, #22, #22, #00
		db	#00, #EE, #88, #EE, #22, #AA, #EE, #00
		db	#00, #EE, #88, #EE, #AA, #AA, #EE, #00
		db	#00, #EE, #AA, #22, #22, #22, #22, #00
		db	#00, #EE, #AA, #EE, #AA, #AA, #EE, #00
		db	#00, #EE, #AA, #EE, #22, #AA, #EE, #00
		db	#00, #00, #00, #44, #00, #44, #00, #00
		db	#00, #00, #00, #44, #00, #44, #88, #00
		db	#00, #00, #22, #44, #88, #44, #22, #00
		db	#00, #00, #00, #EE, #00, #EE, #00, #00
		db	#00, #00, #88, #44, #22, #44, #88, #00
		db	#00, #EE, #AA, #66, #44, #00, #44, #00
		db	#00, #44, #AA, #EE, #EE, #88, #66, #00
		db	#00, #EE, #AA, #EE, #AA, #AA, #AA, #00
		db	#00, #EE, #AA, #CC, #AA, #AA, #EE, #00
		db	#00, #EE, #AA, #88, #88, #AA, #EE, #00
		db	#00, #CC, #AA, #AA, #AA, #AA, #CC, #00
		db	#00, #EE, #88, #CC, #88, #88, #EE, #00
		db	#00, #EE, #88, #CC, #88, #88, #88, #00
		db	#00, #EE, #AA, #88, #EE, #AA, #EE, #00
		db	#00, #AA, #AA, #EE, #AA, #AA, #AA, #00
		db	#00, #EE, #44, #44, #44, #44, #EE, #00
		db	#00, #EE, #22, #22, #22, #AA, #EE, #00
		db	#00, #AA, #AA, #CC, #AA, #AA, #AA, #00
		db	#00, #88, #88, #88, #88, #AA, #EE, #00
		db	#00, #AA, #EE, #AA, #AA, #AA, #AA, #00
		db	#00, #EE, #AA, #AA, #AA, #AA, #AA, #00
		db	#00, #EE, #AA, #AA, #AA, #AA, #EE, #00
		db	#00, #EE, #AA, #EE, #88, #88, #88, #00
		db	#00, #EE, #AA, #AA, #AA, #EE, #EE, #00
		db	#00, #EE, #AA, #EE, #CC, #AA, #AA, #00
		db	#00, #EE, #88, #EE, #22, #AA, #EE, #00
		db	#00, #EE, #44, #44, #44, #44, #44, #00
		db	#00, #AA, #AA, #AA, #AA, #AA, #EE, #00
		db	#00, #AA, #AA, #AA, #AA, #AA, #44, #00
		db	#00, #AA, #AA, #EE, #EE, #EE, #44, #00
		db	#00, #AA, #AA, #44, #AA, #AA, #AA, #00
		db	#00, #AA, #AA, #AA, #EE, #22, #EE, #00
		db	#00, #EE, #22, #EE, #88, #AA, #EE, #00
		db	#00, #66, #44, #44, #44, #44, #66, #00
		db	#00, #88, #88, #44, #44, #22, #22, #00
		db	#00, #66, #22, #22, #22, #22, #66, #00
		db	#00, #44, #EE, #44, #44, #44, #44, #00
		db	#00, #00, #00, #00, #00, #00, #EE, #00
		db	#00, #22, #44, #66, #44, #44, #EE, #00
		db	#00, #00, #EE, #22, #EE, #AA, #EE, #00
		db	#00, #88, #88, #EE, #AA, #AA, #EE, #00
		db	#00, #00, #EE, #88, #88, #88, #EE, #00
		db	#00, #22, #22, #EE, #AA, #AA, #EE, #00
		db	#00, #00, #EE, #AA, #EE, #88, #EE, #00
		db	#00, #66, #88, #CC, #88, #88, #88, #00
		db	#00, #00, #EE, #AA, #EE, #22, #EE, #00
		db	#00, #88, #88, #EE, #AA, #AA, #AA, #00
		db	#00, #44, #00, #CC, #44, #44, #EE, #00
		db	#00, #22, #00, #22, #22, #AA, #EE, #00
		db	#00, #88, #88, #AA, #CC, #AA, #AA, #00
		db	#00, #88, #88, #88, #88, #88, #66, #00
		db	#00, #00, #AA, #EE, #AA, #AA, #AA, #00
		db	#00, #00, #EE, #AA, #AA, #AA, #AA, #00
		db	#00, #00, #EE, #AA, #AA, #AA, #EE, #00
		db	#00, #00, #EE, #AA, #EE, #88, #88, #00
		db	#00, #00, #EE, #AA, #EE, #22, #22, #00
		db	#00, #00, #EE, #88, #88, #88, #88, #00
		db	#00, #00, #EE, #88, #EE, #22, #EE, #00
		db	#00, #44, #EE, #44, #44, #44, #66, #00
		db	#00, #00, #AA, #AA, #AA, #AA, #EE, #00
		db	#00, #00, #AA, #AA, #AA, #AA, #44, #00
		db	#00, #00, #AA, #AA, #EE, #EE, #EE, #00
		db	#00, #00, #AA, #AA, #44, #AA, #AA, #00
		db	#00, #00, #AA, #AA, #EE, #22, #CC, #00
		db	#00, #00, #EE, #22, #EE, #88, #EE, #00
		db	#00, #66, #44, #88, #44, #44, #66, #00
		db	#00, #44, #44, #44, #44, #44, #44, #00
		db	#00, #CC, #44, #22, #44, #44, #CC, #00
		db	#00, #AA, #AA, #00, #00, #00, #00, #00
		db	#00, #44, #AA, #AA, #AA, #AA, #EE, #00
		db	#00, #EE, #AA, #88, #88, #AA, #EE, #44
		db	#AA, #00, #AA, #AA, #AA, #AA, #EE, #00
		db	#22, #44, #EE, #AA, #EE, #88, #EE, #00
		db	#44, #AA, #EE, #22, #EE, #AA, #EE, #00
		db	#AA, #00, #EE, #22, #EE, #AA, #EE, #00
		db	#44, #00, #AA, #AA, #AA, #AA, #EE, #00
		db	#22, #44, #EE, #88, #88, #88, #EE, #00
		db	#00, #00, #EE, #88, #88, #88, #EE, #44
		db	#00, #88, #AA, #CC, #88, #88, #66, #00
		db	#AA, #00, #EE, #AA, #EE, #88, #EE, #00
		db	#AA, #00, #EE, #AA, #AA, #AA, #EE, #00
		db	#AA, #00, #EE, #AA, #AA, #AA, #EE, #00
		db	#44, #AA, #CC, #44, #44, #44, #EE, #00
		db	#22, #44, #EE, #22, #EE, #88, #EE, #00
		db	#AA, #00, #EE, #AA, #EE, #AA, #AA, #00
		db	#22, #44, #EE, #AA, #88, #AA, #EE, #00
		db	#22, #44, #EE, #88, #CC, #88, #EE, #00
		db	#22, #44, #88, #88, #88, #AA, #EE, #00
		db	#22, #44, #88, #88, #88, #88, #66, #00
		db	#44, #AA, #EE, #AA, #AA, #AA, #EE, #00
		db	#AA, #00, #EE, #AA, #AA, #AA, #EE, #00
		db	#22, #AA, #88, #88, #88, #AA, #EE, #00
		db	#22, #AA, #88, #88, #88, #88, #66, #00
		db	#22, #44, #EE, #88, #EE, #22, #EE, #00
		db	#22, #44, #EE, #88, #EE, #22, #EE, #00
		db	#AA, #00, #EE, #AA, #AA, #AA, #EE, #00
		db	#AA, #00, #AA, #AA, #AA, #AA, #EE, #00
		db	#AA, #44, #EE, #44, #44, #44, #44, #00
		db	#22, #22, #44, #EE, #44, #44, #66, #00
		db	#00, #88, #AA, #CC, #88, #AA, #EE, #00
		db	#00, #00, #00, #AA, #44, #AA, #00, #00
		db	#AA, #44, #EE, #88, #88, #88, #EE, #00
		db	#22, #44, #EE, #22, #EE, #AA, #EE, #00
		db	#22, #44, #00, #CC, #44, #44, #EE, #00
		db	#22, #44, #EE, #AA, #AA, #AA, #EE, #00
		db	#22, #44, #AA, #AA, #AA, #AA, #EE, #00
		db	#00, #EE, #AA, #EE, #AA, #AA, #AA, #22
		db	#00, #00, #EE, #22, #EE, #AA, #EE, #22
		db	#AA, #44, #EE, #22, #EE, #88, #EE, #00
		db	#AA, #44, #EE, #22, #EE, #88, #EE, #00
		db	#00, #EE, #88, #CC, #88, #88, #EE, #22
		db	#00, #00, #EE, #AA, #EE, #88, #EE, #22
		db	#00, #00, #00, #00, #00, #00, #00, #00
		db	#22, #44, #EE, #22, #EE, #88, #EE, #00
		db	#AA, #44, #EE, #88, #88, #88, #EE, #00
		db	#00, #00, #EE, #88, #EE, #22, #EE, #44
		db	#00, #00, #00, #44, #88, #44, #00, #00
		db	#00, #00, #00, #88, #44, #88, #00, #00
		db	#00, #AA, #00, #AA, #00, #AA, #00, #AA
		db	#44, #AA, #44, #AA, #44, #AA, #44, #AA
		db	#AA, #EE, #AA, #EE, #AA, #EE, #AA, #EE
		db	#22, #22, #22, #22, #22, #22, #22, #22
		db	#22, #22, #22, #22, #EE, #22, #22, #22
		db	#22, #44, #EE, #AA, #EE, #AA, #AA, #00
		db	#44, #AA, #EE, #AA, #EE, #AA, #AA, #00
		db	#AA, #44, #EE, #88, #CC, #88, #EE, #00
		db	#00, #EE, #88, #EE, #22, #AA, #EE, #44
		db	#55, #55, #DD, #11, #DD, #55, #55, #55
		db	#55, #55, #55, #55, #55, #55, #55, #55
		db	#00, #00, #FF, #11, #DD, #55, #55, #55
		db	#55, #55, #DD, #11, #FF, #00, #00, #00
		db	#44, #00, #EE, #22, #EE, #88, #EE, #00
		db	#44, #00, #EE, #22, #EE, #88, #EE, #00
		db	#00, #00, #00, #00, #EE, #22, #22, #22
		db	#44, #44, #44, #44, #77, #00, #00, #00
		db	#22, #22, #22, #22, #FF, #00, #00, #00
		db	#00, #00, #00, #00, #FF, #22, #22, #22
		db	#44, #44, #44, #44, #77, #44, #44, #44
		db	#00, #00, #00, #00, #FF, #00, #00, #00
		db	#20, #20, #20, #20, #FF, #20, #20, #20
		db	#AA, #44, #EE, #AA, #EE, #AA, #AA, #00
		db	#AA, #44, #EE, #22, #EE, #AA, #EE, #00
		db	#AA, #AA, #BB, #88, #FF, #00, #00, #00
		db	#00, #00, #FF, #88, #BB, #AA, #AA, #AA
		db	#55, #55, #DD, #00, #FF, #00, #00, #00
		db	#00, #00, #FF, #00, #DD, #55, #55, #55
		db	#AA, #AA, #BB, #88, #BB, #AA, #AA, #AA
		db	#00, #00, #FF, #00, #FF, #00, #00, #00
		db	#55, #55, #DD, #00, #DD, #55, #55, #55
		db	#00, #00, #AA, #EE, #AA, #EE, #AA, #00
		db	#00, #66, #22, #EE, #AA, #AA, #EE, #00
		db	#00, #CC, #AA, #EE, #AA, #AA, #CC, #00
		db	#AA, #44, #CC, #AA, #AA, #AA, #CC, #00
		db	#AA, #00, #EE, #88, #CC, #88, #EE, #00
		db	#44, #66, #22, #EE, #AA, #AA, #EE, #00
		db	#AA, #44, #EE, #AA, #AA, #AA, #AA, #00
		db	#22, #44, #EE, #44, #44, #44, #EE, #00
		db	#44, #AA, #EE, #44, #44, #44, #EE, #00
		db	#AA, #44, #EE, #AA, #EE, #88, #EE, #00
		db	#22, #22, #22, #22, #EE, #00, #00, #00
		db	#00, #00, #00, #00, #77, #44, #44, #44
		db	#00, #EE, #EE, #EE, #EE, #EE, #EE, #00
		db	#00, #00, #00, #00, #EE, #EE, #EE, #00
		db	#00, #00, #EE, #44, #44, #44, #44, #22
		db	#44, #00, #AA, #AA, #AA, #AA, #EE, #00
		db	#00, #EE, #EE, #EE, #00, #00, #00, #00
		db	#22, #44, #EE, #AA, #AA, #AA, #EE, #00
		db	#00, #00, #CC, #AA, #CC, #AA, #EE, #00
		db	#44, #AA, #EE, #AA, #AA, #AA, #EE, #00
		db	#22, #44, #EE, #AA, #AA, #AA, #AA, #00
		db	#22, #44, #EE, #AA, #AA, #AA, #AA, #00
		db	#AA, #44, #EE, #AA, #AA, #AA, #AA, #00
		db	#AA, #44, #EE, #88, #EE, #22, #EE, #00
		db	#AA, #44, #EE, #88, #EE, #22, #EE, #00
		db	#22, #44, #EE, #AA, #EE, #CC, #AA, #00
		db	#22, #44, #AA, #AA, #AA, #AA, #EE, #00
		db	#22, #44, #EE, #88, #88, #88, #88, #00
		db	#AA, #00, #AA, #AA, #AA, #AA, #EE, #00
		db	#22, #44, #AA, #AA, #EE, #22, #CC, #00
		db	#22, #44, #AA, #AA, #EE, #22, #EE, #00
		db	#00, #44, #EE, #44, #44, #44, #66, #44
		db	#00, #08, #10, #00, #00, #00, #00, #00
		db	#00, #00, #00, #00, #EE, #00, #00, #00
		db	#00, #AA, #AA, #00, #00, #00, #00, #00
		db	#44, #44, #44, #44, #44, #44, #44, #44
		db	#AA, #44, #00, #00, #00, #00, #00, #00
		db	#AA, #44, #00, #00, #00, #00, #00, #00
		db	#66, #44, #EE, #AA, #EE, #44, #CC, #00
		db	#00, #44, #00, #EE, #00, #44, #00, #00
		db	#AA, #AA, #AA, #AA, #AA, #AA, #AA, #AA
		db	#44, #AA, #44, #00, #00, #00, #00, #00
		db	#00, #AA, #00, #00, #00, #00, #00, #00
		db	#00, #44, #00, #00, #00, #00, #00, #00
		db	#AA, #00, #AA, #AA, #AA, #AA, #EE, #00
		db	#AA, #44, #EE, #AA, #EE, #CC, #AA, #00
		db	#AA, #44, #EE, #88, #88, #88, #88, #00
		db	#00, #00, #00, #00, #00, #00, #00, #FF
		db	#00, #00, #00, #00, #00, #00, #00, #00


FT
		ds	256
;aby bylo vic pro stack
stack
A0STACK		equ	$-FT

A0LEN		equ	$-start
A0LAST

		org	#AD00
A0SPACE		equ	$-A0LAST
TEXT		ds	32

IXPOS		ds	2
HLPOS		ds	2
NUM		ds	6
KOEF1		ds	2
KOEF2		ds	2
POS		ds	2
VER		ds	2
DRV1		ds	2
DRV2		ds	2
DRV3		ds	2
DRV4		ds	2
DRV9		ds	1
;0=ne
MEM128		ds	1
;0 nebo 128
BIOS		ds	1
MSGB		ds	2
FASTMEM		ds	32
SECTOUT
BOOT		ds	1024
SECTIN		ds	1024
MSGSP1		ds	2
MSGSP2		ds	82
MSGST		ds	540
STORE		ds	2052

A0COMP

		savebin "fc01delta.cod",start,$-start
		